{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"themes/hexo-theme-pure/source/favicon.png","path":"favicon.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-pure/source/fonts/iconfont.eot","path":"fonts/iconfont.eot","modified":1,"renderable":1},{"_id":"themes/hexo-theme-pure/source/fonts/README.md","path":"fonts/README.md","modified":1,"renderable":1},{"_id":"themes/hexo-theme-pure/source/fonts/iconfont.woff","path":"fonts/iconfont.woff","modified":1,"renderable":1},{"_id":"themes/hexo-theme-pure/source/fonts/iconfont.ttf","path":"fonts/iconfont.ttf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-pure/source/images/avatar.jpg","path":"images/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-pure/source/images/xingqiu-qrcode.jpg","path":"images/xingqiu-qrcode.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-pure/source/js/application.min.js","path":"js/application.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-pure/source/images/thumb-default.png","path":"images/thumb-default.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-pure/source/js/insight.js","path":"js/insight.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-pure/source/js/application.js","path":"js/application.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-pure/source/js/jquery.min.js","path":"js/jquery.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-pure/source/js/plugin.js","path":"js/plugin.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-pure/source/js/plugin.min.js","path":"js/plugin.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-pure/source/css/style.css","path":"css/style.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-pure/source/css/style.min.css","path":"css/style.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-pure/source/fonts/iconfont.svg","path":"fonts/iconfont.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-pure/source/images/donate/alipay.jpg","path":"images/donate/alipay.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-pure/source/images/donate/wechatpay.jpg","path":"images/donate/wechatpay.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-pure/source/images/favatar/SzsFox-logo.png","path":"images/favatar/SzsFox-logo.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-pure/source/images/favatar/chuangzaoshi-logo.png","path":"images/favatar/chuangzaoshi-logo.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-pure/source/images/favatar/idesign-logo.png","path":"images/favatar/idesign-logo.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-pure/source/js/plugin.js.map","path":"js/plugin.js.map","modified":1,"renderable":1},{"_id":"themes/hexo-theme-pure/source/images/avtor.jpg","path":"images/avtor.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/hexo-theme-pure/README.cn.md","hash":"a634af4addbb57088935e060e8ec6035ea7bab76","modified":1584526185753},{"_id":"themes/hexo-theme-pure/.gitignore","hash":"dbb41a2f30c98cb9de173d82736c46266c901cda","modified":1584526185753},{"_id":"themes/hexo-theme-pure/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1584526185753},{"_id":"themes/hexo-theme-pure/README.md","hash":"5861cec81712af9197a210fd5212d007aad8b0de","modified":1584526185754},{"_id":"themes/hexo-theme-pure/_config.yml","hash":"3e4168557a4590e872279b9ad570165ebed283b1","modified":1586348180209},{"_id":"themes/hexo-theme-pure/_config.yml.example","hash":"4714f87fdb6d4a6ea5ece84f4fe37f922337f14d","modified":1584526185755},{"_id":"themes/hexo-theme-pure/package.json","hash":"a61723eead5cae2c4d9f0f05cf40d2de7c286fee","modified":1584526185796},{"_id":"source/CNAME","hash":"45ca7d025f8902606b7b55d75846c81447525cdb","modified":1586481942968},{"_id":"themes/hexo-theme-pure/.git/config","hash":"960ae89874082f17906562856ff22242435099f0","modified":1584526185741},{"_id":"themes/hexo-theme-pure/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1584526185737},{"_id":"themes/hexo-theme-pure/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1584525651366},{"_id":"themes/hexo-theme-pure/.git/index","hash":"4d3237b98a0248bfa5901a14f1b0b4f065072089","modified":1584526981529},{"_id":"themes/hexo-theme-pure/.git/packed-refs","hash":"873c07a9f1db6543aa91f5e85a419e512fa04501","modified":1584526185729},{"_id":"themes/hexo-theme-pure/languages/en.yml","hash":"167ea0db98f4db156ea68c4644f64c0287ae2b6f","modified":1584526185761},{"_id":"themes/hexo-theme-pure/languages/zh-CN.yml","hash":"057ebc043f09449af9768791c89c86dfc2938365","modified":1584526185761},{"_id":"themes/hexo-theme-pure/languages/default.yml","hash":"167ea0db98f4db156ea68c4644f64c0287ae2b6f","modified":1584526185761},{"_id":"themes/hexo-theme-pure/languages/zh-TW.yml","hash":"6d27c3114be539b8783ffce944f68b2e26a8c3b9","modified":1584526185762},{"_id":"themes/hexo-theme-pure/layout/archive.ejs","hash":"ded5d953b35666e30f4c6e48e2d2c62af8d95ebf","modified":1584526185792},{"_id":"themes/hexo-theme-pure/layout/about.ejs","hash":"4f5c769e183249b12eb9d3141432bc0039519730","modified":1584526185791},{"_id":"themes/hexo-theme-pure/layout/categories.ejs","hash":"22a2bc1712dd9ba1a3027e875d636132d334fb00","modified":1584526185793},{"_id":"themes/hexo-theme-pure/layout/category.ejs","hash":"3ca5651bbce7b0c280c906468f2eb18c2e55ebcb","modified":1584526185793},{"_id":"themes/hexo-theme-pure/layout/index.ejs","hash":"07825d8d8b21eb7b694f5585567b9df5c5a91a60","modified":1584526185793},{"_id":"themes/hexo-theme-pure/layout/books.ejs","hash":"6c64719cd7071b5319b01339aa524fdaab391385","modified":1584526185793},{"_id":"themes/hexo-theme-pure/layout/layout.ejs","hash":"a29ab2e881954a252bfc0dc1a7eb5aa52768dd2a","modified":1584526185794},{"_id":"themes/hexo-theme-pure/layout/page.ejs","hash":"5c27475c176627e6e2e6a16172eb6980e56bcaff","modified":1584526185794},{"_id":"themes/hexo-theme-pure/layout/post.ejs","hash":"5c27475c176627e6e2e6a16172eb6980e56bcaff","modified":1584526185795},{"_id":"themes/hexo-theme-pure/layout/links.ejs","hash":"77c5d1561e2c606c5b3bb39610133d84324074df","modified":1584526185794},{"_id":"themes/hexo-theme-pure/layout/tags.ejs","hash":"29f19a6ed10f8b1f069259a7aeaaacddcfaa2ed4","modified":1584526185796},{"_id":"themes/hexo-theme-pure/layout/repository.ejs","hash":"fe4b3e051a8b0debe9ee22c2cc2cc935d92ee23f","modified":1584526185795},{"_id":"themes/hexo-theme-pure/layout/tag.ejs","hash":"df60564c162f7ad3422f8959dfea19351857a7cd","modified":1584526185795},{"_id":"themes/hexo-theme-pure/scripts/thumbnail.js","hash":"e667a611f9baac270281b765832020d50bf8fb7f","modified":1584526185811},{"_id":"themes/hexo-theme-pure/source/favicon.png","hash":"89875d3b018552e396fc5f0bd8ff5d9f5d4a5d71","modified":1584526185825},{"_id":"source/_posts/Coordinator源码分析.md","hash":"854719a2d8d42186ce2235b2a88ce510d6e39a87","modified":1584865033517},{"_id":"source/_posts/Java中的锁.md","hash":"6e0b9838a2d59bb348d577a003cb88e8407e6cc4","modified":1586357908417},{"_id":"source/_posts/Java线程池原理.md","hash":"33d365a63faeb6642e493bb31d426ef5d9e7ae4f","modified":1585036174527},{"_id":"source/_posts/zookeeper-ZAB协议.md","hash":"ca38962f9001661696c69bf4e371ab6c048b5c9e","modified":1586398214647},{"_id":"source/_posts/【翻译】Zookeeper01-Zookeeper简介.md","hash":"9d054476d20d3a80268829dbcbfbd74cc9446b8a","modified":1586348369823},{"_id":"source/_posts/火焰图实践.md","hash":"51c930cf48f7877ad442dd130eb1e8424f619d97","modified":1584865517887},{"_id":"source/_posts/组件运维常用命令.md","hash":"6061625ec4d52b2a8266cceb2b53d66aa4c741f4","modified":1585053169048},{"_id":"themes/hexo-theme-pure/screenshot/pure-theme-blue.png","hash":"6146890a68d5ea9d343c48d50151ddd5a2a1872c","modified":1584526185797},{"_id":"themes/hexo-theme-pure/screenshot/pure-theme-black.png","hash":"10b40f398af7eb7e8ba2bf2f2a959d8779fc1fe1","modified":1584526185797},{"_id":"themes/hexo-theme-pure/screenshot/pure-theme-green.png","hash":"12ec0c6033cb2762839fdf75434bbb4fbf946022","modified":1584526185799},{"_id":"themes/hexo-theme-pure/screenshot/pure-theme-purple.png","hash":"9855d2eb0acd23370209354f232471df8f4f72e2","modified":1584526185801},{"_id":"themes/hexo-theme-pure/screenshot/pure.png","hash":"8f4cfd8d7edfa4fbffdf375291302d9807f5cc1c","modified":1584526185802},{"_id":"themes/hexo-theme-pure/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1584525651470},{"_id":"themes/hexo-theme-pure/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1584525651486},{"_id":"themes/hexo-theme-pure/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1584525651488},{"_id":"themes/hexo-theme-pure/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1584525651492},{"_id":"themes/hexo-theme-pure/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1584525651489},{"_id":"themes/hexo-theme-pure/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1584525651506},{"_id":"themes/hexo-theme-pure/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1584525651495},{"_id":"themes/hexo-theme-pure/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1584525651504},{"_id":"themes/hexo-theme-pure/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1584525651508},{"_id":"themes/hexo-theme-pure/.git/logs/HEAD","hash":"cfcac11d588b7584dfaa3769706878d5071facdf","modified":1584526185739},{"_id":"themes/hexo-theme-pure/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1584525651510},{"_id":"themes/hexo-theme-pure/_source/404/index.md","hash":"8d493f624fdd29c8d0266767e56f343d549e16d8","modified":1584526185756},{"_id":"themes/hexo-theme-pure/_source/about/index.md","hash":"9c95cabb533409d06daefc4295021ad199761efc","modified":1584526185757},{"_id":"themes/hexo-theme-pure/_source/_data/links.yml","hash":"aa443a4508550820c77c2a4f6abff1d38ad85054","modified":1584526185757},{"_id":"themes/hexo-theme-pure/_source/books/index.md","hash":"cf4163959c23244059cbbbc1c0fe379cc3b2cb73","modified":1584526185758},{"_id":"themes/hexo-theme-pure/_source/categories/index.md","hash":"5d2a4f103d27bebbe3eef1604649d0f5c6d86ac6","modified":1584526185758},{"_id":"themes/hexo-theme-pure/_source/_data/gallery.yml","hash":"e2b3fad87be3d1cfde1effa655d39678ee90907e","modified":1584526185756},{"_id":"themes/hexo-theme-pure/_source/repository/index.md","hash":"ed0e082c30f233dd5c140d188f1e4bce44bdbf79","modified":1584526185759},{"_id":"themes/hexo-theme-pure/layout/_common/head.ejs","hash":"a48ef0fa22712b29ec044b9e5134461f3a21c10d","modified":1584526185763},{"_id":"themes/hexo-theme-pure/_source/tags/index.md","hash":"42e9c904ea63b0a7dd4033e2e8f153225bc5cda5","modified":1584526185760},{"_id":"themes/hexo-theme-pure/_source/links/index.md","hash":"febcf87eb0ab3c5080578275d25f3970bba39625","modified":1584526185759},{"_id":"themes/hexo-theme-pure/layout/_common/social.ejs","hash":"a35a2610e9da762df96587b76b51470507a88cad","modified":1584526185764},{"_id":"themes/hexo-theme-pure/layout/_common/footer.ejs","hash":"cdc48ec70d9202b947f2a9334234d038d7014a7d","modified":1584526185763},{"_id":"themes/hexo-theme-pure/layout/_common/header.ejs","hash":"3d739d1e2b2991927c08ec222db123830a44a519","modified":1584526185763},{"_id":"themes/hexo-theme-pure/layout/_search/baidu.ejs","hash":"67aab280a3ea34429f086cc5c3de7de17727c567","modified":1584526185787},{"_id":"themes/hexo-theme-pure/layout/_search/insight.ejs","hash":"4af3e92ef98bedba9680d45699cb04dde4640536","modified":1584526185788},{"_id":"themes/hexo-theme-pure/layout/_common/script.ejs","hash":"0031114d2a58f8601c2869f78ceedc75a10be90d","modified":1584526185763},{"_id":"themes/hexo-theme-pure/layout/_search/swiftype.ejs","hash":"4baeca36e410181300ae7d47ba1fb4755bcfcff0","modified":1584526185789},{"_id":"themes/hexo-theme-pure/layout/_search/index-mobile.ejs","hash":"c726e234c0166da69fdfbd3dd613a5eaf4c80258","modified":1584526185787},{"_id":"themes/hexo-theme-pure/layout/_search/index.ejs","hash":"f8d5a9c3f777250f5fb6512bba585307f784d5cd","modified":1584526185788},{"_id":"themes/hexo-theme-pure/layout/_partial/archive-book.ejs","hash":"977f97f3636947006ad738e502858c46d4cd5ec7","modified":1584526185764},{"_id":"themes/hexo-theme-pure/layout/_partial/archive-list.ejs","hash":"c66c86d6a6a90e00494c380603426fc0f4006311","modified":1584526185765},{"_id":"themes/hexo-theme-pure/layout/_partial/archive-link.ejs","hash":"fe4d9bf526d8176683cea89b8561ced571374db0","modified":1584526185765},{"_id":"themes/hexo-theme-pure/layout/_partial/archive-category.ejs","hash":"9c364fd6b5172890784141802f5f466241d233fd","modified":1584526185765},{"_id":"themes/hexo-theme-pure/layout/_partial/archive-repository.ejs","hash":"e39dc762d9fe238cede462532e40eaa3d8651122","modified":1584526185766},{"_id":"themes/hexo-theme-pure/layout/_partial/archive-post.ejs","hash":"13039fec017332029122ef99901755fcecbfc8ea","modified":1584526185766},{"_id":"themes/hexo-theme-pure/layout/_partial/article-about.ejs","hash":"7b80319daeb63401d1745b81cd9a6d1d21a4fb60","modified":1584526185768},{"_id":"themes/hexo-theme-pure/layout/_partial/archive-tag.ejs","hash":"5de90244c3cedad531cccc03c40e5f9a3aef3c61","modified":1584526185767},{"_id":"themes/hexo-theme-pure/layout/_partial/archive.ejs","hash":"4d6793f50d41fbd47dc50aa36b24d496006bba6c","modified":1584526185767},{"_id":"themes/hexo-theme-pure/layout/_partial/article.ejs","hash":"0f9b71de0087d1f777d92c5a0f3873971aec5a5b","modified":1584526185768},{"_id":"themes/hexo-theme-pure/layout/_partial/pagination.ejs","hash":"41a319642da5af07d6cfb8525796aa610b721879","modified":1584526185769},{"_id":"themes/hexo-theme-pure/layout/_partial/item-post.ejs","hash":"9f755b0da1ea928dece32c2050d8a04b3a9fb13b","modified":1584526185768},{"_id":"themes/hexo-theme-pure/layout/_partial/sidebar.ejs","hash":"2aa8a9f90838e7c105e75e6d3d03cbf860bb1239","modified":1584526185774},{"_id":"themes/hexo-theme-pure/layout/_partial/sidebar-about.ejs","hash":"e10ea0176ba87e64888234bafedc01c92544352c","modified":1584526185773},{"_id":"themes/hexo-theme-pure/layout/_partial/sidebar-toc.ejs","hash":"152538ceceb0fdef65c46470ebf0189f7b891c5b","modified":1584526185774},{"_id":"themes/hexo-theme-pure/layout/_script/analytics.ejs","hash":"e756a81f8c20a187fb863b9689f2f1fa15e2f4e1","modified":1584526185782},{"_id":"themes/hexo-theme-pure/layout/_script/comment.ejs","hash":"6f951510bab9dc15474b6664e0329defccf29a30","modified":1584526185782},{"_id":"themes/hexo-theme-pure/layout/_script/fancybox.ejs","hash":"8f1be01e70a15b2c31ae57d8c6bce54622ebf8a7","modified":1584526185785},{"_id":"themes/hexo-theme-pure/layout/_script/pv.ejs","hash":"fb9b5f16029f2ccef4b83cf4facfdcdd748b65b4","modified":1584526185786},{"_id":"themes/hexo-theme-pure/layout/_script/douban.ejs","hash":"143087db0573772b0bdaf7f93312553158942ec7","modified":1584526185783},{"_id":"themes/hexo-theme-pure/layout/_script/repository.ejs","hash":"14f2e7d4c1055ff6a5f5867dc0e9a9f6f4c28fe1","modified":1584526185786},{"_id":"themes/hexo-theme-pure/layout/_script/mathjax.ejs","hash":"f618393ab971b2faa80d541f2e6a553d9ace9816","modified":1584526185785},{"_id":"themes/hexo-theme-pure/layout/_widget/archive.ejs","hash":"af8ad7f62877764b75d5272d9d899fd6c8e3845c","modified":1584526185789},{"_id":"themes/hexo-theme-pure/layout/_widget/category.ejs","hash":"331b7642a0f58b9088b937436ab39076a4c5dd7e","modified":1584526185790},{"_id":"themes/hexo-theme-pure/layout/_script/search.ejs","hash":"7be33dc260ce788aa1a2cd3bd0386d95057533cb","modified":1584526185787},{"_id":"themes/hexo-theme-pure/layout/_widget/recent_posts.ejs","hash":"8942d60311797a591ba2d157c5cdd23e85ceb694","modified":1584526185790},{"_id":"themes/hexo-theme-pure/layout/_widget/board.ejs","hash":"acd27451be52703e670ce0b313f2da6fa24071e4","modified":1584526185790},{"_id":"themes/hexo-theme-pure/layout/_widget/tagcloud.ejs","hash":"3291108e5411c48b2c5b3e17adace6ffa90d1c29","modified":1584526185791},{"_id":"themes/hexo-theme-pure/layout/_widget/tag.ejs","hash":"487628925da5fcac91463cdad3d9e55d071bd5ed","modified":1584526185791},{"_id":"themes/hexo-theme-pure/source/fonts/iconfont.eot","hash":"6819d9bb643bdeafc17bfecb0746ae641b018fdf","modified":1584526185827},{"_id":"themes/hexo-theme-pure/source/fonts/README.md","hash":"c5772b99ad81291fb137b330813f866bdceea0a3","modified":1584526185826},{"_id":"themes/hexo-theme-pure/source/fonts/iconfont.woff","hash":"78d29194287b8885d25212048c4f787705212a6e","modified":1584526185829},{"_id":"themes/hexo-theme-pure/source/fonts/iconfont.ttf","hash":"9b8837f9f79cf6ab794736301d0665345183a20c","modified":1584526185829},{"_id":"themes/hexo-theme-pure/source/images/avatar.jpg","hash":"f86eafc318f3900319b25057811720168f24d248","modified":1584526185831},{"_id":"themes/hexo-theme-pure/source/images/xingqiu-qrcode.jpg","hash":"ef2c2848dc79db6df7c752510651ed8ba57f2daf","modified":1584526185834},{"_id":"themes/hexo-theme-pure/source/js/application.min.js","hash":"34d765e982c7d6360c37f82202d99f63ac40e408","modified":1584526185837},{"_id":"themes/hexo-theme-pure/source/images/thumb-default.png","hash":"e8403b97ed9251f9f5207765b0ce796c5000b4ba","modified":1584526185834},{"_id":"themes/hexo-theme-pure/source/js/insight.js","hash":"298e8ca42517984bd26f34caa4c45560b0e909ad","modified":1584526185837},{"_id":"themes/hexo-theme-pure/source/js/application.js","hash":"46d1fb207ce5f0acb83803f927985dfcea86f9ef","modified":1584526185836},{"_id":"source/_posts/Coordinator源码分析/DruidCoordinator源码分析02.png","hash":"a2d91068a93064cd36f44e8bec9807244ecec45f","modified":1584855248021},{"_id":"source/_posts/Coordinator源码分析/DruidCoordinator源码分析01.png","hash":"bcb1009d5d1036fec885605d00b1df54ad3764d7","modified":1584855222629},{"_id":"source/_posts/Coordinator源码分析/DruidCoordinator源码分析03.png","hash":"0d86d62fb6aee40326342d99b378f8dbcf5cc425","modified":1584855272934},{"_id":"source/_posts/Java线程池原理/01.png","hash":"982a1c587e890d9a3bafbec20eccaa80496eef82","modified":1584956615916},{"_id":"source/_posts/Java线程池原理/02.png","hash":"997ca26f459f5f0824357b4a4e57157e12f0ccc5","modified":1584967199391},{"_id":"source/_posts/Java线程池原理/05.png","hash":"ef76a17007a5f58ebca571ec7cb658e872bb3feb","modified":1585016079066},{"_id":"source/_posts/Java线程池原理/03.png","hash":"b2316d0cfe380a431c924fa0a88210dfd227648b","modified":1584976941024},{"_id":"source/_posts/Java线程池原理/04.png","hash":"6b1ab7d16c849f60fad25e46f782525206a69e46","modified":1584977729070},{"_id":"source/_posts/Java线程池原理/06.png","hash":"f33f135a361c40f4a1a5128c69e242fb811c17e4","modified":1585030987430},{"_id":"source/_posts/【翻译】Zookeeper01-Zookeeper简介/zknamespace.jpg","hash":"d0207adf88ed531749a86d9b100f503b121e3c67","modified":1586315688910},{"_id":"source/_posts/【翻译】Zookeeper01-Zookeeper简介/zkcomponents.jpg","hash":"d00d3bc0b6b2022510d5a4a23b67c9c7c25a7d2e","modified":1586347869776},{"_id":"source/_posts/火焰图实践/04.png","hash":"3caab234fb6c3fc76d284e1d3cbc69e1e89ccee6","modified":1584864342006},{"_id":"themes/hexo-theme-pure/source/js/jquery.min.js","hash":"5a9dcfbef655a2668e78baebeaa8dc6f41d8dabb","modified":1584526185838},{"_id":"themes/hexo-theme-pure/source/js/plugin.js","hash":"a8524d42b8621bfaa06602a163c6a1f82702b91d","modified":1584526185839},{"_id":"themes/hexo-theme-pure/source/js/plugin.min.js","hash":"07fe34638f9832702c5f81d8583c5e4e8b3d9659","modified":1584526185841},{"_id":"source/_posts/【翻译】Zookeeper01-Zookeeper简介/zkservice.jpg","hash":"3045c7da0e924031f16bc17b91d610a4fd043833","modified":1586347856641},{"_id":"source/_posts/火焰图实践/02.png","hash":"a00ea3f748625a149f33cc8a7dfa38fe8f2595e8","modified":1584864317220},{"_id":"source/_posts/火焰图实践/03.png","hash":"bc7374e776a112657e6827acefe160ce3aed8836","modified":1584864328016},{"_id":"themes/hexo-theme-pure/.git/refs/heads/master","hash":"27b3e45c36f92e067332428d34c55b39077e0068","modified":1584526185738},{"_id":"themes/hexo-theme-pure/layout/_partial/post/copyright.ejs","hash":"a9d3d05428e5844a07706c7fcfeb842e44a36a64","modified":1584526185770},{"_id":"themes/hexo-theme-pure/layout/_partial/post/date.ejs","hash":"7d4979652998abf92a64bfae8157b70d6e514057","modified":1584526185770},{"_id":"themes/hexo-theme-pure/layout/_partial/post/comment.ejs","hash":"3c0da69fcea6ccfd97b82d50e740107a88eec5c4","modified":1584526185770},{"_id":"themes/hexo-theme-pure/layout/_partial/post/category.ejs","hash":"fcee6b4aef8b6c4627831ff8dbb2d73478511426","modified":1584526185769},{"_id":"themes/hexo-theme-pure/layout/_partial/post/donate.ejs","hash":"a251dc34d660601a2e8b7d98b3bfe2b9023dbbce","modified":1584526185770},{"_id":"themes/hexo-theme-pure/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1584526185771},{"_id":"themes/hexo-theme-pure/layout/_partial/post/nav.ejs","hash":"95eabc0fe4033ec61b240a16eeaf7dc62a9e3da1","modified":1584526185772},{"_id":"themes/hexo-theme-pure/layout/_partial/post/pv.ejs","hash":"ec3ccf322432afc2761f860c5a3000ac34d46e4c","modified":1584526185772},{"_id":"themes/hexo-theme-pure/layout/_partial/post/tag.ejs","hash":"39f53ead07f75c181a7ba93e586dd1b8171620f1","modified":1584526185772},{"_id":"themes/hexo-theme-pure/layout/_partial/post/thumbnail.ejs","hash":"080d5c5f3e95accf51893a7092695fe32d34a087","modified":1584526185773},{"_id":"themes/hexo-theme-pure/layout/_script/_comment/gitment.ejs","hash":"a64852076483395738a398deb4c10bdb0f3b7b71","modified":1584526185779},{"_id":"themes/hexo-theme-pure/layout/_script/_comment/gitalk.ejs","hash":"fb01f1631c3ae7fe6211dc03233506cb344229be","modified":1584526185778},{"_id":"themes/hexo-theme-pure/layout/_script/_comment/disqus.ejs","hash":"a051e3eddc75586e69131c29ab8c89d69626e0fd","modified":1584526185776},{"_id":"themes/hexo-theme-pure/layout/_script/_comment/valine.ejs","hash":"acf81f9a59dc45f197d723f70484de5fcd166577","modified":1584526185780},{"_id":"themes/hexo-theme-pure/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1584526185773},{"_id":"themes/hexo-theme-pure/layout/_partial/post/wordcount.ejs","hash":"bd06c4c8449ed96aabf655fe1ae3be1f0707b81e","modified":1584526185773},{"_id":"themes/hexo-theme-pure/layout/_script/_comment/livere.ejs","hash":"5ab997d5ee4475d2f89f882fab4a52648dbe0e30","modified":1584526185779},{"_id":"themes/hexo-theme-pure/layout/_script/_comment/youyan.ejs","hash":"095649a173573d03b5845c2e331ec7be976b152a","modified":1584526185780},{"_id":"themes/hexo-theme-pure/layout/_script/_search/insight.ejs","hash":"3543c11d060feaf9381b5d87564b01ffef0e0a59","modified":1584526185782},{"_id":"themes/hexo-theme-pure/layout/_script/_search/baidu.ejs","hash":"9b60ffa2e2725a993e9cecfb81ddedd9b9361011","modified":1584526185781},{"_id":"themes/hexo-theme-pure/layout/_script/_analytics/baidu-analytics.ejs","hash":"f314be7860c1d5930f1600d010e3120ba5c85325","modified":1584526185775},{"_id":"themes/hexo-theme-pure/layout/_script/_analytics/google-analytics.ejs","hash":"54f1dc9375cbdb65464e0ac1b58847aa5e8bc6a5","modified":1584526185775},{"_id":"themes/hexo-theme-pure/layout/_script/_analytics/tencent-analytics.ejs","hash":"77defb41a1613a758ff5a6a5128c6107fc584190","modified":1584526185776},{"_id":"themes/hexo-theme-pure/source/css/style.css","hash":"3b693ce41c2e35ece4773593e94b4c17aeaee02f","modified":1584526185814},{"_id":"themes/hexo-theme-pure/source/css/style.min.css","hash":"1d23abc76726ebe042f7df4749f00f8f73338444","modified":1584526185825},{"_id":"themes/hexo-theme-pure/source/fonts/iconfont.svg","hash":"25929e6e74f7027acd1f6467a67e95b153bcd8d5","modified":1584526185828},{"_id":"themes/hexo-theme-pure/source/images/donate/alipay.jpg","hash":"03a93bf7c0f66087075c34fa090d54fc8adb7734","modified":1584582373915},{"_id":"themes/hexo-theme-pure/source/images/donate/wechatpay.jpg","hash":"2d05e6151ecda72f079941cc33106fc546bf5a69","modified":1584582360795},{"_id":"themes/hexo-theme-pure/source/images/favatar/SzsFox-logo.png","hash":"d71fcc73b7bc2a439d8c7ba461137856d190bd76","modified":1584526185833},{"_id":"themes/hexo-theme-pure/source/images/favatar/chuangzaoshi-logo.png","hash":"7fa5734072050952159a02d330bbc008b5a99122","modified":1584526185833},{"_id":"themes/hexo-theme-pure/source/images/favatar/idesign-logo.png","hash":"6b150a2dbb9912b7a7662255c27e4d4baaecee71","modified":1584526185833},{"_id":"themes/hexo-theme-pure/source/js/plugin.js.map","hash":"1730c0cc660f863120aca0a439d7264e2e245fc5","modified":1584526185840},{"_id":"themes/hexo-theme-pure/.git/objects/pack/pack-5c3cb781ec92f297dfba07b4d4e75f16d791cb0c.idx","hash":"9251a318d4d5d3a29958ee71fcc3933c0964ca5d","modified":1584526185466},{"_id":"source/_posts/火焰图实践/01.png","hash":"eba613c5e742a876077133f235aa25c8be351acc","modified":1584864303997},{"_id":"themes/hexo-theme-pure/.git/logs/refs/heads/master","hash":"cfcac11d588b7584dfaa3769706878d5071facdf","modified":1584526185738},{"_id":"themes/hexo-theme-pure/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1584526185736},{"_id":"themes/hexo-theme-pure/.git/logs/refs/remotes/origin/HEAD","hash":"cfcac11d588b7584dfaa3769706878d5071facdf","modified":1584526185735},{"_id":"themes/hexo-theme-pure/screenshot/pure.psd","hash":"a31cea40b45bdc31f051fca2f1e2f4ecbaee1a94","modified":1584526185810},{"_id":"themes/hexo-theme-pure/source/images/avtor.jpg","hash":"0fd821708405836e26256d37618b091573a3dbc0","modified":1584854047021},{"_id":"themes/hexo-theme-pure/.git/objects/pack/pack-5c3cb781ec92f297dfba07b4d4e75f16d791cb0c.pack","hash":"db8af5329c57d13ac45afc0a0c34ca5c4c16544b","modified":1584526185465},{"_id":"public/baidusitemap.xml","hash":"7b121621984c7a0872689e3a4990c78150fd0418","modified":1586483530394},{"_id":"public/sitemap.xml","hash":"93fda62d8f5a2d25ebd6edc3620837d64029fac4","modified":1586483530394},{"_id":"public/2020/04/09/zookeeper-ZAB协议/index.html","hash":"5b72297c514dda8d80b9685c74a92a169586b7ad","modified":1586483530833},{"_id":"public/2020/04/08/【翻译】Zookeeper01-Zookeeper简介/index.html","hash":"92572833980e538a4b83e37cacd06a4e15321b4c","modified":1586483530833},{"_id":"public/2020/03/24/组件运维常用命令/index.html","hash":"e4c9ef5ef2b481af597c1fa1eb7405d3e91ef3fa","modified":1586483530834},{"_id":"public/2020/03/24/Java中的锁/index.html","hash":"673e4a51f787c89d57e53d80303d50f2e65cfdf6","modified":1586483530834},{"_id":"public/2020/03/23/Java线程池原理/index.html","hash":"84bf18f525a676de051310b35481fd6cc851a946","modified":1586483530834},{"_id":"public/2020/03/22/火焰图实践/index.html","hash":"bf53901d61b78cde5be111a446d91b0876f1d19c","modified":1586483530835},{"_id":"public/2020/03/20/Coordinator源码分析/index.html","hash":"9864f30687e9fce032a248d4ddd5f54ce9899c94","modified":1586483530835},{"_id":"public/archives/index.html","hash":"194a4f19ce134b283ecf44f81b2706d222eccf9b","modified":1586483530835},{"_id":"public/archives/2020/index.html","hash":"5b4ad0525aac1422e6b2bf392aa57f110864578b","modified":1586483530836},{"_id":"public/archives/2020/03/index.html","hash":"76cf8222620d924d7ed45280b5be199070dc5f77","modified":1586483530836},{"_id":"public/archives/2020/04/index.html","hash":"147436b9015e123e596ca7c6fce49310bea2cb71","modified":1586483530836},{"_id":"public/categories/Java多线程/index.html","hash":"7d28a375691e17006cc9f672b5b18b35bb8ea385","modified":1586483530836},{"_id":"public/categories/Apache-Druid/index.html","hash":"fd7e3a52821b74eec431fc6effd6fb2d8ed3c220","modified":1586483530836},{"_id":"public/categories/大数据组件/index.html","hash":"c74b164518f242734a627b4e92f9cb636d3c5b77","modified":1586483530836},{"_id":"public/categories/运维/index.html","hash":"28bcd5fb9809de643f7def07badeab7be68c4228","modified":1586483530836},{"_id":"public/categories/代码分析/index.html","hash":"d9710ca7a9826b35632af4dddaaedf63eff80487","modified":1586483530836},{"_id":"public/categories/大数据组件/zookeeper/index.html","hash":"97e6e510342c8007c072db025cdfa9021bed1727","modified":1586483530836},{"_id":"public/index.html","hash":"8e0f8bb3f5cf17762d934dba197c6925a3544527","modified":1586483530836},{"_id":"public/tags/java/index.html","hash":"6dbd8b1be69e670332d7e4c5535e4c0aa06c8aee","modified":1586483530837},{"_id":"public/tags/多线程/index.html","hash":"951ad8adf6897caec9f48d2692bffbe353232f89","modified":1586483530837},{"_id":"public/tags/asyn-syn/index.html","hash":"1d2914f7fbd1997e49b6cdcc904a56ce27a8f8b5","modified":1586483530837},{"_id":"public/tags/JUC/index.html","hash":"3b07bda31abf0ead1109368bb3de264feeacc09e","modified":1586483530837},{"_id":"public/tags/Apache-Druid/index.html","hash":"9e4b6f5e7beedb5ef149fd49acd7f5ea676fe30b","modified":1586483530837},{"_id":"public/tags/Bigdata/index.html","hash":"b01a18585d36fa354105adee481876fa680a118a","modified":1586483530837},{"_id":"public/tags/OLAP/index.html","hash":"8b6cb4a2bfbb8f9c26b416cdcf66f259feaa9cb6","modified":1586483530837},{"_id":"public/tags/Java/index.html","hash":"4d3bce1c64200eab590f468f155a01ee86039f0a","modified":1586483530837},{"_id":"public/tags/线程池/index.html","hash":"731e4fdcd4ca7d6e3e901172d08b8ac0816ac6fd","modified":1586483530837},{"_id":"public/tags/zookeeper/index.html","hash":"36efff9b00ec7e12f88f581fdd6f901b92068442","modified":1586483530837},{"_id":"public/tags/大数据/index.html","hash":"fe811ed13857543bf0242635e62026dd8b02baf9","modified":1586483530837},{"_id":"public/tags/Linux/index.html","hash":"ca43ead532b988d17b02bca988bccf0b148ad882","modified":1586483530838},{"_id":"public/tags/大数据组件/index.html","hash":"47c8da1beff597017547ff9f999d788b3a7cc211","modified":1586483530838},{"_id":"public/tags/Problem-Shoting/index.html","hash":"0d1b713c661119f091082485df9b750101c74d47","modified":1586483530838},{"_id":"public/tags/性能分析/index.html","hash":"0393da77b06df80fa794f96bde57cbf926d1df4f","modified":1586483530838},{"_id":"public/tags/火焰图/index.html","hash":"20f98ed8b251b9976dfecd92c1f02163dd750d9c","modified":1586483530838},{"_id":"public/CNAME","hash":"45ca7d025f8902606b7b55d75846c81447525cdb","modified":1586483530850},{"_id":"public/favicon.png","hash":"89875d3b018552e396fc5f0bd8ff5d9f5d4a5d71","modified":1586483530850},{"_id":"public/fonts/iconfont.woff","hash":"78d29194287b8885d25212048c4f787705212a6e","modified":1586483530850},{"_id":"public/fonts/iconfont.eot","hash":"6819d9bb643bdeafc17bfecb0746ae641b018fdf","modified":1586483530850},{"_id":"public/fonts/iconfont.ttf","hash":"9b8837f9f79cf6ab794736301d0665345183a20c","modified":1586483530851},{"_id":"public/images/avatar.jpg","hash":"f86eafc318f3900319b25057811720168f24d248","modified":1586483530851},{"_id":"public/images/thumb-default.png","hash":"e8403b97ed9251f9f5207765b0ce796c5000b4ba","modified":1586483530851},{"_id":"public/images/xingqiu-qrcode.jpg","hash":"ef2c2848dc79db6df7c752510651ed8ba57f2daf","modified":1586483530851},{"_id":"public/images/donate/alipay.jpg","hash":"03a93bf7c0f66087075c34fa090d54fc8adb7734","modified":1586483530851},{"_id":"public/images/favatar/SzsFox-logo.png","hash":"d71fcc73b7bc2a439d8c7ba461137856d190bd76","modified":1586483530851},{"_id":"public/images/favatar/chuangzaoshi-logo.png","hash":"7fa5734072050952159a02d330bbc008b5a99122","modified":1586483530851},{"_id":"public/images/favatar/idesign-logo.png","hash":"6b150a2dbb9912b7a7662255c27e4d4baaecee71","modified":1586483530851},{"_id":"public/images/donate/wechatpay.jpg","hash":"2d05e6151ecda72f079941cc33106fc546bf5a69","modified":1586483530851},{"_id":"public/2020/03/20/Coordinator源码分析/DruidCoordinator源码分析02.png","hash":"a2d91068a93064cd36f44e8bec9807244ecec45f","modified":1586483530851},{"_id":"public/2020/03/20/Coordinator源码分析/DruidCoordinator源码分析01.png","hash":"bcb1009d5d1036fec885605d00b1df54ad3764d7","modified":1586483530851},{"_id":"public/2020/03/20/Coordinator源码分析/DruidCoordinator源码分析03.png","hash":"0d86d62fb6aee40326342d99b378f8dbcf5cc425","modified":1586483530851},{"_id":"public/2020/04/08/【翻译】Zookeeper01-Zookeeper简介/zkcomponents.jpg","hash":"d00d3bc0b6b2022510d5a4a23b67c9c7c25a7d2e","modified":1586483530851},{"_id":"public/2020/04/08/【翻译】Zookeeper01-Zookeeper简介/zknamespace.jpg","hash":"d0207adf88ed531749a86d9b100f503b121e3c67","modified":1586483530851},{"_id":"public/2020/03/22/火焰图实践/04.png","hash":"3caab234fb6c3fc76d284e1d3cbc69e1e89ccee6","modified":1586483530852},{"_id":"public/2020/03/23/Java线程池原理/03.png","hash":"b2316d0cfe380a431c924fa0a88210dfd227648b","modified":1586483530852},{"_id":"public/2020/03/23/Java线程池原理/02.png","hash":"997ca26f459f5f0824357b4a4e57157e12f0ccc5","modified":1586483530852},{"_id":"public/2020/03/23/Java线程池原理/01.png","hash":"982a1c587e890d9a3bafbec20eccaa80496eef82","modified":1586483530852},{"_id":"public/2020/03/23/Java线程池原理/04.png","hash":"6b1ab7d16c849f60fad25e46f782525206a69e46","modified":1586483530852},{"_id":"public/2020/03/23/Java线程池原理/05.png","hash":"ef76a17007a5f58ebca571ec7cb658e872bb3feb","modified":1586483530852},{"_id":"public/2020/03/23/Java线程池原理/06.png","hash":"f33f135a361c40f4a1a5128c69e242fb811c17e4","modified":1586483530852},{"_id":"public/2020/04/08/【翻译】Zookeeper01-Zookeeper简介/zkservice.jpg","hash":"3045c7da0e924031f16bc17b91d610a4fd043833","modified":1586483530866},{"_id":"public/2020/03/22/火焰图实践/02.png","hash":"a00ea3f748625a149f33cc8a7dfa38fe8f2595e8","modified":1586483530871},{"_id":"public/2020/03/22/火焰图实践/03.png","hash":"bc7374e776a112657e6827acefe160ce3aed8836","modified":1586483530871},{"_id":"public/js/application.js","hash":"46d1fb207ce5f0acb83803f927985dfcea86f9ef","modified":1586483530876},{"_id":"public/js/application.min.js","hash":"34d765e982c7d6360c37f82202d99f63ac40e408","modified":1586483530876},{"_id":"public/js/insight.js","hash":"298e8ca42517984bd26f34caa4c45560b0e909ad","modified":1586483530876},{"_id":"public/fonts/README.html","hash":"43b6265aeccff3f9d495e2b44d07b249a2197bd7","modified":1586483530876},{"_id":"public/js/jquery.min.js","hash":"5a9dcfbef655a2668e78baebeaa8dc6f41d8dabb","modified":1586483530876},{"_id":"public/js/plugin.js","hash":"a8524d42b8621bfaa06602a163c6a1f82702b91d","modified":1586483530876},{"_id":"public/js/plugin.min.js","hash":"07fe34638f9832702c5f81d8583c5e4e8b3d9659","modified":1586483530876},{"_id":"public/css/style.css","hash":"3b693ce41c2e35ece4773593e94b4c17aeaee02f","modified":1586483530876},{"_id":"public/css/style.min.css","hash":"1d23abc76726ebe042f7df4749f00f8f73338444","modified":1586483530876},{"_id":"public/fonts/iconfont.svg","hash":"25929e6e74f7027acd1f6467a67e95b153bcd8d5","modified":1586483530877},{"_id":"public/js/plugin.js.map","hash":"1730c0cc660f863120aca0a439d7264e2e245fc5","modified":1586483530877},{"_id":"public/2020/03/22/火焰图实践/01.png","hash":"eba613c5e742a876077133f235aa25c8be351acc","modified":1586483530878},{"_id":"public/images/avtor.jpg","hash":"0fd821708405836e26256d37618b091573a3dbc0","modified":1586483530936}],"Category":[{"name":"Java多线程","_id":"ck8tjbxtt00026gon63b3uml1"},{"name":"Apache Druid","_id":"ck8tjbxtz00076gondfignklh"},{"name":"大数据组件","_id":"ck8tjbxu2000c6gont5l63suz"},{"name":"运维","_id":"ck8tjbxu4000g6goncx7c6mle"},{"name":"代码分析","_id":"ck8tjbxu5000i6gonvnatfpfv"},{"name":"zookeeper","parent":"ck8tjbxu2000c6gont5l63suz","_id":"ck8tjbxu6000n6gonbatfp7wt"}],"Data":[],"Page":[],"Post":[{"title":"Java中的锁","date":"2020-03-24T06:55:42.000Z","_content":"\n有锁编程主要是保证不同线程对同一资源写操作的可见性，以防止不同线程读取到的内存状态不一致导致的不可预期结果。而Java中的有锁编程可以通过volatile，synchronized以及各种Lock类实现。那么，为了更好的理解并发读写的一致性，就不得不探究一下这些机制的实现和区别了。\n\n<!-- more -->\n\n## 1. Synchronized， Volatile和Lock的区别\n\n### 1.1 Volatile\n\nvolatile 是Java自带关键字，可以保证被修饰变量的**单次读写**是可见的。类似于i++这样的复合操作是没法保证操作的同步。Volatile是相较于Sychronized和Lock而言要更加的轻量级，无线程切换开销，但缺点是只能修饰单个变量。\n\n### 1.2 Sychronized\n\nSychronized是通过锁实现同步的，而Java中的每个对象都可以作为一个锁。Sychronize可以修饰方法，代码块。当程序运行时，单个线程执行同步代码之前必须要获取到锁，代码执行结束或者抛出异常之后必须要释放锁。这个过程程序要不用关心。\n\n### 1.3 Lock\n\nJava中的Lock其实就是一个个提供了lock()和unlock()方法的类。而针对不同的场景，也有很多不同设计的锁可以选择。  \n\n#### 1.3.1 公平锁/非公平锁\n\n对于互斥资源而言，在某个时刻只能由一个线程获取，而其他线程会进入等待状态。公平与非公平是相对于等待的线程而言。一般情况下，我们认为等待时间很长的话，公平一点就让我早点获取到锁，类似于FIFO，这种锁称之为公平锁；而不顾等待锁的时长，任何线程任何时刻竞争锁都有可能成功，这种能够插队的情况就是非公平锁。公平锁对于有优先级的线程而言，不太友好，优先级高但是等待时间较短的线程无法很快获取到资源。而非公平锁则有可能导致线程无法获取到锁，饿死。 \n\n#### 1.3.2 乐观锁/悲观锁  \n\n按照是都对资源加锁，可以将所分为悲观锁和乐观锁。悲观锁和乐观锁是两种对立的锁思想，而不是指具体的两种锁。  \n\n悲观锁悲观地认为所有拿到线程的资源都会对资源进行操作，所以为了保证同步，需要对资源加锁。线程在持有资源的时候会对资源加锁，这样其他线程只能都能等到锁释放后，竞争获取到锁才能访问资源。这样可以保证操作的原子性和数据的可见性。Java中的Synchronized和ReentrantLock等独占锁都是悲观锁。\n\n而乐观锁与之相反，它乐观地认为大家拿到资源都不会对数据进行更新，所以访问资源的时候不需要加锁。但是它在写数据的时候需要判断数据是否进行了更改。乐观锁是一种无锁编程的思想，一般通过CAS实现，可以保证数据操作的可见性。缺点是CAS自旋会占用较多的CPU资源，而且CAS无法避免ABA问题。\n\n以上，悲观锁多用于写操作多于读操作的场景，而乐观锁则相反。  \n\n#### 1.3.3 独占锁/共享锁\n\n独占锁又称之为排他锁。顾名思义，这种锁在某个时刻只能由一个线程获取，而其他的线程在锁被占有的情况下，只能等待。Java中的Synchronized和大多数Lock都是独占锁。  \n\n共享锁是指锁能够被多个线程所拥有。如果线程对某个资源加上了共享锁之后，其他线程则只能在这个资源上加共享锁，而不能加独占锁。或的共享锁的线程只能读取数据，不能更改数据。\n\n读写锁中的读锁就是共享锁，而写锁则为独占锁。  \n\n#### 1.3.4 自旋锁/互斥锁  \n\n在多核CPU中可能有多个线程同时执行，但是对于某些锁而言，在某个时刻只能由一个线程拥有。那么，没有获取到锁的线程该做些什么呢？1.如果线程一直循环尝试获取锁的话，这种锁称之为自旋锁；2.如果将没有获取到锁的线程阻塞起来，等待唤起，这种锁成为互斥锁。\n\n#### 1.3.5  重入锁/不可重入锁\n\n当一个线程获取到锁之后未释放的情况下可以再次获取该锁的锁成为可重入锁。可重入锁能够在一定程度上避免死锁的情况。如下代码，如果锁不可重入，就会在执行B方法的lock.lock()时死锁：\n\n```java\npublic void A(){\n    lock.lock();\n    try {\n        B();\n    } finally {\n        lock.unlock();\n    }\n}\n\npublic void B() {\n    lock.lock();\n    try {\n        //do something\n    } finally {\n        lock.unlock();\n    }\n}\n```\n\n\n\n\n\n\n\n","source":"_posts/Java中的锁.md","raw":"---\ntitle: Java中的锁\ndate: 2020-03-24 14:55:42\ntags:\n - java\n - 多线程\n - asyn/syn\n - JUC\ncategories: Java多线程\n\n---\n\n有锁编程主要是保证不同线程对同一资源写操作的可见性，以防止不同线程读取到的内存状态不一致导致的不可预期结果。而Java中的有锁编程可以通过volatile，synchronized以及各种Lock类实现。那么，为了更好的理解并发读写的一致性，就不得不探究一下这些机制的实现和区别了。\n\n<!-- more -->\n\n## 1. Synchronized， Volatile和Lock的区别\n\n### 1.1 Volatile\n\nvolatile 是Java自带关键字，可以保证被修饰变量的**单次读写**是可见的。类似于i++这样的复合操作是没法保证操作的同步。Volatile是相较于Sychronized和Lock而言要更加的轻量级，无线程切换开销，但缺点是只能修饰单个变量。\n\n### 1.2 Sychronized\n\nSychronized是通过锁实现同步的，而Java中的每个对象都可以作为一个锁。Sychronize可以修饰方法，代码块。当程序运行时，单个线程执行同步代码之前必须要获取到锁，代码执行结束或者抛出异常之后必须要释放锁。这个过程程序要不用关心。\n\n### 1.3 Lock\n\nJava中的Lock其实就是一个个提供了lock()和unlock()方法的类。而针对不同的场景，也有很多不同设计的锁可以选择。  \n\n#### 1.3.1 公平锁/非公平锁\n\n对于互斥资源而言，在某个时刻只能由一个线程获取，而其他线程会进入等待状态。公平与非公平是相对于等待的线程而言。一般情况下，我们认为等待时间很长的话，公平一点就让我早点获取到锁，类似于FIFO，这种锁称之为公平锁；而不顾等待锁的时长，任何线程任何时刻竞争锁都有可能成功，这种能够插队的情况就是非公平锁。公平锁对于有优先级的线程而言，不太友好，优先级高但是等待时间较短的线程无法很快获取到资源。而非公平锁则有可能导致线程无法获取到锁，饿死。 \n\n#### 1.3.2 乐观锁/悲观锁  \n\n按照是都对资源加锁，可以将所分为悲观锁和乐观锁。悲观锁和乐观锁是两种对立的锁思想，而不是指具体的两种锁。  \n\n悲观锁悲观地认为所有拿到线程的资源都会对资源进行操作，所以为了保证同步，需要对资源加锁。线程在持有资源的时候会对资源加锁，这样其他线程只能都能等到锁释放后，竞争获取到锁才能访问资源。这样可以保证操作的原子性和数据的可见性。Java中的Synchronized和ReentrantLock等独占锁都是悲观锁。\n\n而乐观锁与之相反，它乐观地认为大家拿到资源都不会对数据进行更新，所以访问资源的时候不需要加锁。但是它在写数据的时候需要判断数据是否进行了更改。乐观锁是一种无锁编程的思想，一般通过CAS实现，可以保证数据操作的可见性。缺点是CAS自旋会占用较多的CPU资源，而且CAS无法避免ABA问题。\n\n以上，悲观锁多用于写操作多于读操作的场景，而乐观锁则相反。  \n\n#### 1.3.3 独占锁/共享锁\n\n独占锁又称之为排他锁。顾名思义，这种锁在某个时刻只能由一个线程获取，而其他的线程在锁被占有的情况下，只能等待。Java中的Synchronized和大多数Lock都是独占锁。  \n\n共享锁是指锁能够被多个线程所拥有。如果线程对某个资源加上了共享锁之后，其他线程则只能在这个资源上加共享锁，而不能加独占锁。或的共享锁的线程只能读取数据，不能更改数据。\n\n读写锁中的读锁就是共享锁，而写锁则为独占锁。  \n\n#### 1.3.4 自旋锁/互斥锁  \n\n在多核CPU中可能有多个线程同时执行，但是对于某些锁而言，在某个时刻只能由一个线程拥有。那么，没有获取到锁的线程该做些什么呢？1.如果线程一直循环尝试获取锁的话，这种锁称之为自旋锁；2.如果将没有获取到锁的线程阻塞起来，等待唤起，这种锁成为互斥锁。\n\n#### 1.3.5  重入锁/不可重入锁\n\n当一个线程获取到锁之后未释放的情况下可以再次获取该锁的锁成为可重入锁。可重入锁能够在一定程度上避免死锁的情况。如下代码，如果锁不可重入，就会在执行B方法的lock.lock()时死锁：\n\n```java\npublic void A(){\n    lock.lock();\n    try {\n        B();\n    } finally {\n        lock.unlock();\n    }\n}\n\npublic void B() {\n    lock.lock();\n    try {\n        //do something\n    } finally {\n        lock.unlock();\n    }\n}\n```\n\n\n\n\n\n\n\n","slug":"Java中的锁","published":1,"updated":"2020-04-08T14:58:28.417Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8tjbxtm00006gon0701585i","content":"<p>有锁编程主要是保证不同线程对同一资源写操作的可见性，以防止不同线程读取到的内存状态不一致导致的不可预期结果。而Java中的有锁编程可以通过volatile，synchronized以及各种Lock类实现。那么，为了更好的理解并发读写的一致性，就不得不探究一下这些机制的实现和区别了。</p>\n<a id=\"more\"></a>\n<h2 id=\"1-Synchronized，-Volatile和Lock的区别\"><a href=\"#1-Synchronized，-Volatile和Lock的区别\" class=\"headerlink\" title=\"1. Synchronized， Volatile和Lock的区别\"></a>1. Synchronized， Volatile和Lock的区别</h2><h3 id=\"1-1-Volatile\"><a href=\"#1-1-Volatile\" class=\"headerlink\" title=\"1.1 Volatile\"></a>1.1 Volatile</h3><p>volatile 是Java自带关键字，可以保证被修饰变量的<strong>单次读写</strong>是可见的。类似于i++这样的复合操作是没法保证操作的同步。Volatile是相较于Sychronized和Lock而言要更加的轻量级，无线程切换开销，但缺点是只能修饰单个变量。</p>\n<h3 id=\"1-2-Sychronized\"><a href=\"#1-2-Sychronized\" class=\"headerlink\" title=\"1.2 Sychronized\"></a>1.2 Sychronized</h3><p>Sychronized是通过锁实现同步的，而Java中的每个对象都可以作为一个锁。Sychronize可以修饰方法，代码块。当程序运行时，单个线程执行同步代码之前必须要获取到锁，代码执行结束或者抛出异常之后必须要释放锁。这个过程程序要不用关心。</p>\n<h3 id=\"1-3-Lock\"><a href=\"#1-3-Lock\" class=\"headerlink\" title=\"1.3 Lock\"></a>1.3 Lock</h3><p>Java中的Lock其实就是一个个提供了lock()和unlock()方法的类。而针对不同的场景，也有很多不同设计的锁可以选择。  </p>\n<h4 id=\"1-3-1-公平锁-非公平锁\"><a href=\"#1-3-1-公平锁-非公平锁\" class=\"headerlink\" title=\"1.3.1 公平锁/非公平锁\"></a>1.3.1 公平锁/非公平锁</h4><p>对于互斥资源而言，在某个时刻只能由一个线程获取，而其他线程会进入等待状态。公平与非公平是相对于等待的线程而言。一般情况下，我们认为等待时间很长的话，公平一点就让我早点获取到锁，类似于FIFO，这种锁称之为公平锁；而不顾等待锁的时长，任何线程任何时刻竞争锁都有可能成功，这种能够插队的情况就是非公平锁。公平锁对于有优先级的线程而言，不太友好，优先级高但是等待时间较短的线程无法很快获取到资源。而非公平锁则有可能导致线程无法获取到锁，饿死。 </p>\n<h4 id=\"1-3-2-乐观锁-悲观锁\"><a href=\"#1-3-2-乐观锁-悲观锁\" class=\"headerlink\" title=\"1.3.2 乐观锁/悲观锁\"></a>1.3.2 乐观锁/悲观锁</h4><p>按照是都对资源加锁，可以将所分为悲观锁和乐观锁。悲观锁和乐观锁是两种对立的锁思想，而不是指具体的两种锁。  </p>\n<p>悲观锁悲观地认为所有拿到线程的资源都会对资源进行操作，所以为了保证同步，需要对资源加锁。线程在持有资源的时候会对资源加锁，这样其他线程只能都能等到锁释放后，竞争获取到锁才能访问资源。这样可以保证操作的原子性和数据的可见性。Java中的Synchronized和ReentrantLock等独占锁都是悲观锁。</p>\n<p>而乐观锁与之相反，它乐观地认为大家拿到资源都不会对数据进行更新，所以访问资源的时候不需要加锁。但是它在写数据的时候需要判断数据是否进行了更改。乐观锁是一种无锁编程的思想，一般通过CAS实现，可以保证数据操作的可见性。缺点是CAS自旋会占用较多的CPU资源，而且CAS无法避免ABA问题。</p>\n<p>以上，悲观锁多用于写操作多于读操作的场景，而乐观锁则相反。  </p>\n<h4 id=\"1-3-3-独占锁-共享锁\"><a href=\"#1-3-3-独占锁-共享锁\" class=\"headerlink\" title=\"1.3.3 独占锁/共享锁\"></a>1.3.3 独占锁/共享锁</h4><p>独占锁又称之为排他锁。顾名思义，这种锁在某个时刻只能由一个线程获取，而其他的线程在锁被占有的情况下，只能等待。Java中的Synchronized和大多数Lock都是独占锁。  </p>\n<p>共享锁是指锁能够被多个线程所拥有。如果线程对某个资源加上了共享锁之后，其他线程则只能在这个资源上加共享锁，而不能加独占锁。或的共享锁的线程只能读取数据，不能更改数据。</p>\n<p>读写锁中的读锁就是共享锁，而写锁则为独占锁。  </p>\n<h4 id=\"1-3-4-自旋锁-互斥锁\"><a href=\"#1-3-4-自旋锁-互斥锁\" class=\"headerlink\" title=\"1.3.4 自旋锁/互斥锁\"></a>1.3.4 自旋锁/互斥锁</h4><p>在多核CPU中可能有多个线程同时执行，但是对于某些锁而言，在某个时刻只能由一个线程拥有。那么，没有获取到锁的线程该做些什么呢？1.如果线程一直循环尝试获取锁的话，这种锁称之为自旋锁；2.如果将没有获取到锁的线程阻塞起来，等待唤起，这种锁成为互斥锁。</p>\n<h4 id=\"1-3-5-重入锁-不可重入锁\"><a href=\"#1-3-5-重入锁-不可重入锁\" class=\"headerlink\" title=\"1.3.5  重入锁/不可重入锁\"></a>1.3.5  重入锁/不可重入锁</h4><p>当一个线程获取到锁之后未释放的情况下可以再次获取该锁的锁成为可重入锁。可重入锁能够在一定程度上避免死锁的情况。如下代码，如果锁不可重入，就会在执行B方法的lock.lock()时死锁：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">A</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        B();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">B</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//do something</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>有锁编程主要是保证不同线程对同一资源写操作的可见性，以防止不同线程读取到的内存状态不一致导致的不可预期结果。而Java中的有锁编程可以通过volatile，synchronized以及各种Lock类实现。那么，为了更好的理解并发读写的一致性，就不得不探究一下这些机制的实现和区别了。</p>","more":"<h2 id=\"1-Synchronized，-Volatile和Lock的区别\"><a href=\"#1-Synchronized，-Volatile和Lock的区别\" class=\"headerlink\" title=\"1. Synchronized， Volatile和Lock的区别\"></a>1. Synchronized， Volatile和Lock的区别</h2><h3 id=\"1-1-Volatile\"><a href=\"#1-1-Volatile\" class=\"headerlink\" title=\"1.1 Volatile\"></a>1.1 Volatile</h3><p>volatile 是Java自带关键字，可以保证被修饰变量的<strong>单次读写</strong>是可见的。类似于i++这样的复合操作是没法保证操作的同步。Volatile是相较于Sychronized和Lock而言要更加的轻量级，无线程切换开销，但缺点是只能修饰单个变量。</p>\n<h3 id=\"1-2-Sychronized\"><a href=\"#1-2-Sychronized\" class=\"headerlink\" title=\"1.2 Sychronized\"></a>1.2 Sychronized</h3><p>Sychronized是通过锁实现同步的，而Java中的每个对象都可以作为一个锁。Sychronize可以修饰方法，代码块。当程序运行时，单个线程执行同步代码之前必须要获取到锁，代码执行结束或者抛出异常之后必须要释放锁。这个过程程序要不用关心。</p>\n<h3 id=\"1-3-Lock\"><a href=\"#1-3-Lock\" class=\"headerlink\" title=\"1.3 Lock\"></a>1.3 Lock</h3><p>Java中的Lock其实就是一个个提供了lock()和unlock()方法的类。而针对不同的场景，也有很多不同设计的锁可以选择。  </p>\n<h4 id=\"1-3-1-公平锁-非公平锁\"><a href=\"#1-3-1-公平锁-非公平锁\" class=\"headerlink\" title=\"1.3.1 公平锁/非公平锁\"></a>1.3.1 公平锁/非公平锁</h4><p>对于互斥资源而言，在某个时刻只能由一个线程获取，而其他线程会进入等待状态。公平与非公平是相对于等待的线程而言。一般情况下，我们认为等待时间很长的话，公平一点就让我早点获取到锁，类似于FIFO，这种锁称之为公平锁；而不顾等待锁的时长，任何线程任何时刻竞争锁都有可能成功，这种能够插队的情况就是非公平锁。公平锁对于有优先级的线程而言，不太友好，优先级高但是等待时间较短的线程无法很快获取到资源。而非公平锁则有可能导致线程无法获取到锁，饿死。 </p>\n<h4 id=\"1-3-2-乐观锁-悲观锁\"><a href=\"#1-3-2-乐观锁-悲观锁\" class=\"headerlink\" title=\"1.3.2 乐观锁/悲观锁\"></a>1.3.2 乐观锁/悲观锁</h4><p>按照是都对资源加锁，可以将所分为悲观锁和乐观锁。悲观锁和乐观锁是两种对立的锁思想，而不是指具体的两种锁。  </p>\n<p>悲观锁悲观地认为所有拿到线程的资源都会对资源进行操作，所以为了保证同步，需要对资源加锁。线程在持有资源的时候会对资源加锁，这样其他线程只能都能等到锁释放后，竞争获取到锁才能访问资源。这样可以保证操作的原子性和数据的可见性。Java中的Synchronized和ReentrantLock等独占锁都是悲观锁。</p>\n<p>而乐观锁与之相反，它乐观地认为大家拿到资源都不会对数据进行更新，所以访问资源的时候不需要加锁。但是它在写数据的时候需要判断数据是否进行了更改。乐观锁是一种无锁编程的思想，一般通过CAS实现，可以保证数据操作的可见性。缺点是CAS自旋会占用较多的CPU资源，而且CAS无法避免ABA问题。</p>\n<p>以上，悲观锁多用于写操作多于读操作的场景，而乐观锁则相反。  </p>\n<h4 id=\"1-3-3-独占锁-共享锁\"><a href=\"#1-3-3-独占锁-共享锁\" class=\"headerlink\" title=\"1.3.3 独占锁/共享锁\"></a>1.3.3 独占锁/共享锁</h4><p>独占锁又称之为排他锁。顾名思义，这种锁在某个时刻只能由一个线程获取，而其他的线程在锁被占有的情况下，只能等待。Java中的Synchronized和大多数Lock都是独占锁。  </p>\n<p>共享锁是指锁能够被多个线程所拥有。如果线程对某个资源加上了共享锁之后，其他线程则只能在这个资源上加共享锁，而不能加独占锁。或的共享锁的线程只能读取数据，不能更改数据。</p>\n<p>读写锁中的读锁就是共享锁，而写锁则为独占锁。  </p>\n<h4 id=\"1-3-4-自旋锁-互斥锁\"><a href=\"#1-3-4-自旋锁-互斥锁\" class=\"headerlink\" title=\"1.3.4 自旋锁/互斥锁\"></a>1.3.4 自旋锁/互斥锁</h4><p>在多核CPU中可能有多个线程同时执行，但是对于某些锁而言，在某个时刻只能由一个线程拥有。那么，没有获取到锁的线程该做些什么呢？1.如果线程一直循环尝试获取锁的话，这种锁称之为自旋锁；2.如果将没有获取到锁的线程阻塞起来，等待唤起，这种锁成为互斥锁。</p>\n<h4 id=\"1-3-5-重入锁-不可重入锁\"><a href=\"#1-3-5-重入锁-不可重入锁\" class=\"headerlink\" title=\"1.3.5  重入锁/不可重入锁\"></a>1.3.5  重入锁/不可重入锁</h4><p>当一个线程获取到锁之后未释放的情况下可以再次获取该锁的锁成为可重入锁。可重入锁能够在一定程度上避免死锁的情况。如下代码，如果锁不可重入，就会在执行B方法的lock.lock()时死锁：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">A</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        B();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">B</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//do something</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"zookeeper-ZAB协议","date":"2020-04-09T02:10:14.000Z","_content":"","source":"_posts/zookeeper-ZAB协议.md","raw":"---\ntitle: zookeeper-ZAB协议\ndate: 2020-04-09 10:10:14\ntags:\n---\n","slug":"zookeeper-ZAB协议","published":1,"updated":"2020-04-09T02:10:14.647Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8tjbxtr00016gonpotp5leo","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Druid-Coordinator源码分析","date":"2020-03-20T09:08:34.000Z","_content":"\nDruid Coordinator 服务在整个Druid架构中的主要作用是协调Segments在历史节点之间的分布。其主要功能包括是segments在historical之间分布均衡，rules管理，segments清理合并等等。  \n\n<!-- more -->\n\n## 源码分析    \n\n> Druid 版本: druid-0.12.3\n\n**DruidCoordinator**  \n\n DruidCoordinator是Coordinator服务的入口，Coordinator启动的流程都是在这个类中开始。首先看一下它的内部类：  \n\n![](DruidCoordinator源码分析01.png)  \n\nDruidCoordinator 一共有三个内部类，即使不看类的定义，我们从类名也可以知道这三个内部类都实现了Runnable接口。在Coordiantor服务中应该是作为三个独立的线程异步执行。  \n我们先大致了解一下每个Runnable的完成的工作。  \n\n**CoordinatorRunnable**\n查看这个类的源码，除了一些判断结构之外，其最主要的实现如下：  \n\n```java\n        // Do coordinator stuff.\n        DruidCoordinatorRuntimeParams params =\n                DruidCoordinatorRuntimeParams.newBuilder()\n                        .withStartTime(startTime)\n                        .withDatasources(metadataSegmentManager.getInventory())\n                        .withDynamicConfigs(getDynamicConfigs())\n                        .withEmitter(emitter)\n                        .withBalancerStrategy(balancerStrategy)\n                        .build();\n        for (DruidCoordinatorHelper helper : helpers) {\n          // Don't read state and run state in the same helper otherwise racy conditions may exist\n          if (coordLeaderSelector.isLeader() && startingLeaderCounter == coordLeaderSelector.localTerm()) {\n            params = helper.run(params);\n          }\n        }\n```\n\n在这里，CoordinatorRunnable首先组装出了一个原始的DruidCoordinatorRuntimeParams 对象(后用params代替)，遍历执行了helper中的run方法。这里是使用了装饰器模式，run方法返回的依然是一个params对象，只是对象又进行了一波加工。  \n查看helpers的定义，知道了这是一个`List<DruidCoordinatorHelper>`。该对象的初始化是通过构造器来完成的。想要明白helper做了什么，就需要找到这个类在什么地方被使用，对象是如何创建的。  \n查看类图，如下：  \n![](DruidCoordinator源码分析02.png) \n`CoordinatorRunnable`作为一个抽象类，在工程中并没有方法直接创建`CoordinatorRunnable`对象，也就是说他的run方法是通过子类调用的。有意思的是，`CoordinatorRunnable`被声明成一个抽象类，但是在它的类定义中并没有声明抽象方法。我的印象中，抽象类多用于模板方法模式。但是乍一看这个类并没有使用这一种模式，唯一一个没有确定的方法就是helper的run方法。也就是说，什么样的helper决定了run方法做了什么样的事。helper是通过构造器创建的，而`CoordinatorRunnable`并没有直接通过`new`关键字创建对象，那么其构造器应该只有子类调用。下面到子类中找helper的定义。    \n\n**CoordinatorHistoricalManagerRunnable**  \n这个类继承了`CoordinatorRunnable`抽象类，且只定义了一个有参构造器，就是这个构造器决定了父类的run方法还要做些什么事。   \n\n```java\nsuper(\n          ImmutableList.of(\n              new DruidCoordinatorSegmentInfoLoader(DruidCoordinator.this),\n              new DruidCoordinatorHelper()\n              {\n                @Override\n                public DruidCoordinatorRuntimeParams run(DruidCoordinatorRuntimeParams params)\n                {\n                      ……//省略方法实现\n                }\n              },\n              new DruidCoordinatorRuleRunner(DruidCoordinator.this),\n              new DruidCoordinatorCleanupUnneeded(DruidCoordinator.this),\n              new DruidCoordinatorCleanupOvershadowed(DruidCoordinator.this),\n              new DruidCoordinatorBalancer(DruidCoordinator.this),\n              new DruidCoordinatorLogger(DruidCoordinator.this)\n          ),\n          startingLeaderCounter\n      );\n```\n\n在这个构造器中传入了一个装载`DruidCoordinatorHelper`的列表。这个列表中helper对象会在`DruidCoordinator`的run方法实现中被调用，运行每个helper的run方法。其父类方法的实现中部分步骤延伸至子类，由子类提供实践方式，其实用的还是模板方法。  \n`DruidCoordinatorHelper`并没有继承任何的接口或者类。也就是说`CoordinatorRunnable`的是在单个线程中调用helper的run方法。  \n从这个helper中我们可以看出，这个CoordinatorHistoricalManagerRunnable主要是实现了segments负责均衡以及Rules管理，segments清理等功能。  \n\n**CoordinatorIndexingServiceRunnable**  \n作为`CoordinatorRunnable`的另外一个子类，它的类定义就简单很多了。  \n\n```java\npublic CoordinatorIndexingServiceRunnable(List<DruidCoordinatorHelper> helpers, final int startingLeaderCounter)\n    {\n      super(helpers, startingLeaderCounter);\n    }\n```\n\n这个类中helpers也是通过其构造器赋值的。但是原理是一样的，传什么样的helper就做什么样的事。  \n\n### start()  \n\n该方法由Lifecycle进行管理，注解为`@LifecycleStart`。在Coordinator启动后首先会在同步代码快中判断是Coordinator服务是有已经启动过了(可能配置了HA)，如实没有启动则会去竞争leader。服务是否已经启动  是通过同步状态`started`来表示的。如果当前服务未启动，则将`started`置为`true`，然后就调用`becomeLeader()`方法来完成后续的操作。  \n\n```java\n public void start()\n  {\n    synchronized (lock) {\n      if (started) {\n        return;\n      }\n      started = true;\n\n      coordLeaderSelector.registerListener(\n          new DruidLeaderSelector.Listener()\n          {\n            @Override\n            public void becomeLeader()\n            {\n              DruidCoordinator.this.becomeLeader();\n            }\n\n            @Override\n            public void stopBeingLeader()\n            {\n              DruidCoordinator.this.stopBeingLeader();\n            }\n          }\n      );\n    }\n  }\n```\n\n`Coordiantor`在宣布服务之前会先去对MetadataStorage中的一些元信息进行操作。  \n\n```java\n//扫描segment\n metadataSegmentManager.start();\n//\n metadataRuleManager.start();\n```\n\n**SQLMetadataSegmentManager之start方法**    \n在这个方法中，主要的实现是在这个类的poll()方法中，而poll()方法是通过单个线程调度的，调度方式为`scheduleWithFixedDelay`。通过这种方式调度就必须要等当前的线程工作执行完毕之后，才会在指定的间隔之后进行下一次调度。也就是说单个线程的执行时间对整个的调度周期有较大的影响。  \n这种方式有两个明显的目的: \n1.当前线程的工作不会阻塞主线程的执行，即二者的操作是异步的；  \n2.线程的工作可以周期性的执行。   \n\n因为必须要等当前的线程执行完之后才会进行下一次调度，所以这个地方它创建了只有一个线程的线程池。  \n\n```java\n      //单个线程的线程池\n      exec = Execs.scheduledSingleThreaded(\"DatabaseSegmentManager-Exec--%d\");\n      final Duration delay = config.get().getPollDuration().toStandardDuration();\n     //对单个线程进行调度\n      exec.scheduleWithFixedDelay(\n          new Runnable()\n          {\n            @Override\n            public void run()\n            {\n              readLock.lock();\n              try {\n                if (localStartOrder == currentStartOrder) {\n                  poll();\n                }\n              }\n              catch (Exception e) {\n                log.makeAlert(e, \"uncaught exception in segment manager polling thread\").emit();\n\n              }\n              finally {\n                readLock.unlock();\n              }\n            }\n          },\n          0,\n          delay.getMillis(),\n          TimeUnit.MILLISECONDS\n      );\n```\n\n **SQLMetadataRuleManager之start方法**    \n调度方式与前面的`start()`方法相似，只是`poll()`方法中扫描的数据不一样了。前者是更新`segments`，这里是更新rules。    \n\n完成上述两个操作之后，Coordinator开始宣布服务。  \n宣布服务成功之后，Coordiantor就开始真正执行对segment和历史节点的管理。首先，它创建了一个list，用来存放要干的事以及调度周期。  \n\n```java\nfinal List<Pair<? extends CoordinatorRunnable, Duration>> coordinatorRunnables = Lists.newArrayList();  \n```\n\n在list中Coordinator放入了`CoordinatorRunnable`的两个子类——`CoordinatorHistoricalManagerRunnable`和`CoordinatorIndexingServiceRunnable`。我们先了解一下这个list如何被使用。    \n\n```java\n      for (final Pair<? extends CoordinatorRunnable, Duration> coordinatorRunnable : coordinatorRunnables) {\n        ScheduledExecutors.scheduleWithFixedDelay(\n            exec,\n            config.getCoordinatorStartDelay(),\n            coordinatorRunnable.rhs,\n            new Callable<ScheduledExecutors.Signal>()\n            {\n              private final CoordinatorRunnable theRunnable = coordinatorRunnable.lhs;\n\n              @Override\n              public ScheduledExecutors.Signal call()\n              {\n                if (coordLeaderSelector.isLeader() && startingLeaderCounter == coordLeaderSelector.localTerm()) {\n                  theRunnable.run();\n                }\n                if (coordLeaderSelector.isLeader()\n                    && startingLeaderCounter == coordLeaderSelector.localTerm()) { // (We might no longer be leader)\n                  return ScheduledExecutors.Signal.REPEAT;\n                } else {\n                  return ScheduledExecutors.Signal.STOP;\n                }\n              }\n            }\n        );\n      }\n```\n\n这里也是使用了`scheduleWithFixedDelay`调度，也就是说每个`CoordinatorRunnable`都是要等上一次执行结束之后才会进行下一次的调度。而且这里需要注意到是调度方法中的`exec`变量是一个容量为1的线程池。也就是说这里的调度相当于从主线程又单独创建一个线程来执行这些`CoordinatorRunnable`。这里采用单个线程池的线程进行调度一是为了保证主线程不会阻塞，另外是为确保数据操作的安全性。\n\n至此我们知道了，Coordinator在启动的时候会先尝试去竞争主节点资格，然后扫描元数据库，这里是异步的。接着会宣布服务。服务宣布后他会去将一些工作封装成`CoordinatorRunnable`,由另外**一个**线程去周期性的调度执行这些Runnable的run方法。而这里使用模板方法，在父类的run方法中会调用helper的run方法，而helper是通过子类来确定。  \n所以，为了探究Coordinator接下来会做什么，我们就需要确认在创建其子类对象是，helper是如何实现的。  \n![](DruidCoordinator源码分析03.png)\n\n查看`CoordinatorHistoricalManagerRunnable`的构造器实现：  \n\n```java\n   public CoordinatorHistoricalManagerRunnable(final int startingLeaderCounter)\n    {\n      super(\n          ImmutableList.of(\n              new DruidCoordinatorSegmentInfoLoader(DruidCoordinator.this),\n            //使用匿名内部类创建了一个Helper对象\n              new DruidCoordinatorHelper()\n              {\n                @Override\n                public DruidCoordinatorRuntimeParams run(DruidCoordinatorRuntimeParams params)\n                {\n                  ……//省略方法的实现\n                }\n              },\n              new DruidCoordinatorRuleRunner(DruidCoordinator.this),\n              new DruidCoordinatorCleanupUnneeded(DruidCoordinator.this),\n              new DruidCoordinatorCleanupOvershadowed(DruidCoordinator.this),\n              new DruidCoordinatorBalancer(DruidCoordinator.this),\n              new DruidCoordinatorLogger(DruidCoordinator.this)\n          ),\n          startingLeaderCounter\n      );\n    }\n\n```\n\n查看源码易知，这里实际上是创建了7个`DruidCoordinatorHelper`，我们可以理解成，Coordinator接下来会串行地完成这七件事。这里为了代码的易读性和整洁度，可以把这个匿名内部类拎出来单独实现一下。  \n`CoordinatorHistoricalManagerRunnable`中完成的工作基本上是与segments管理及历史节点负载均衡相关的。具体的实现可以查看每个Runnable的run方法。  \n\n关于`CoordinatorIndexingServiceRunnable`,我们前面说过，它的helpers是通过调用方传入参数决定的。  \n\n```java\n if (indexingServiceClient != null) {\n        coordinatorRunnables.add(\n            Pair.of(\n                new CoordinatorIndexingServiceRunnable(\n                    makeIndexingServiceHelpers(),\n                    startingLeaderCounter\n                ),\n                config.getCoordinatorIndexingPeriod()\n            )\n        );\n\n\n//makeIndexingServiceHelpersde的实现如下： \n\n private List<DruidCoordinatorHelper> makeIndexingServiceHelpers()\n  {\n    List<DruidCoordinatorHelper> helpers = Lists.newArrayList();\n    helpers.add(new DruidCoordinatorSegmentInfoLoader(DruidCoordinator.this));\n    helpers.addAll(indexingServiceHelpers);\n\n    log.info(\"Done making indexing service helpers [%s]\", helpers);\n    return ImmutableList.copyOf(helpers);\n  }\n\n```\n\n实际上是传入了两个helper,一个是`DruidCoordinatorSegmentInfoLoader`,用来加载segments信息。另一个是`indexingServiceHelpers`，负责完成segment的一些合并工作。  \n最后调用`LookupCoordinatorManager`的start()方法，这里暂时先不讨论。  \n\n现在的问题是，列表中的`CoordinatorRunnable`是通过单个线程来进行调度的，而且helpers也是通过串行的方式实现的。那么，如果单次调度时间过长的话，则会导致很长时间后才会进行下一次的调度。  \n这里我们考虑一下，Druid为什么会选择使用只有一个线程资源的线程池来调度所有的`CoordinatorRunnable`。  \n在单个线程中他们实际上是串行的。串行的好处是，在进程中变量对于内存的可见性得到了保证，坏处是执行效率差。\n如果需要对这里进行改造，串行改并行，我们首先要确定的就是共享内存中的变量有哪些，对共享变量的操作有哪些。\n首先查看父类的run方法，再查看run方法调用的各个helper。细看代码我们不难发现，这里其实就是一个装饰器模式。每个help的run方法都会对params对象进行读写，且大部分都是读操作，只有在返回的时候进行了写操作。\n\n 备注：把匿名内部类抽出来，单独实现，然后再作为参数传递，会让代码看起来整洁很多，如下：\n更改前：\n\n```java\n   public CoordinatorHistoricalManagerRunnable(final int startingLeaderCounter)\n    {\n      super(\n          ImmutableList.of(\n              new DruidCoordinatorSegmentInfoLoader(DruidCoordinator.this),\n            //使用匿名内部类创建了一个Helper对象\n              new DruidCoordinatorHelper()\n              {\n                @Override\n                public DruidCoordinatorRuntimeParams run(DruidCoordinatorRuntimeParams params)\n                {\n                  ……//省略方法的实现\n                }\n              },\n              new DruidCoordinatorRuleRunner(DruidCoordinator.this),\n              new DruidCoordinatorCleanupUnneeded(DruidCoordinator.this),\n              new DruidCoordinatorCleanupOvershadowed(DruidCoordinator.this),\n              new DruidCoordinatorBalancer(DruidCoordinator.this),\n              new DruidCoordinatorLogger(DruidCoordinator.this)\n          ),\n          startingLeaderCounter\n      );\n    }\n\n```\n\n更改后： \n\n```java\npublic CoordinatorHistoricalManagerRunnable(final int startingLeaderCounter)\n    {\n      super(\n          ImmutableList.of(\n              new DruidCoordinatorSegmentInfoLoader(DruidCoordinator.this),\n              new DruidCoordinatorPeonRunner(),\n              new DruidCoordinatorRuleRunner(DruidCoordinator.this),\n              new DruidCoordinatorCleanupUnneeded(DruidCoordinator.this),\n              new DruidCoordinatorCleanupOvershadowed(DruidCoordinator.this),\n              new DruidCoordinatorBalancer(DruidCoordinator.this),\n              new DruidCoordinatorLogger(DruidCoordinator.this)\n          ),\n          startingLeaderCounter\n      );\n    }\n\n```\n\n  ","source":"_posts/Coordinator源码分析.md","raw":"---\ntitle: Druid-Coordinator源码分析\ndate: 2020-03-20 17:08:34\ntags:\n - Apache Druid\n - Bigdata\n - OLAP\ncategories: Apache Druid\n\n---\n\nDruid Coordinator 服务在整个Druid架构中的主要作用是协调Segments在历史节点之间的分布。其主要功能包括是segments在historical之间分布均衡，rules管理，segments清理合并等等。  \n\n<!-- more -->\n\n## 源码分析    \n\n> Druid 版本: druid-0.12.3\n\n**DruidCoordinator**  \n\n DruidCoordinator是Coordinator服务的入口，Coordinator启动的流程都是在这个类中开始。首先看一下它的内部类：  \n\n![](DruidCoordinator源码分析01.png)  \n\nDruidCoordinator 一共有三个内部类，即使不看类的定义，我们从类名也可以知道这三个内部类都实现了Runnable接口。在Coordiantor服务中应该是作为三个独立的线程异步执行。  \n我们先大致了解一下每个Runnable的完成的工作。  \n\n**CoordinatorRunnable**\n查看这个类的源码，除了一些判断结构之外，其最主要的实现如下：  \n\n```java\n        // Do coordinator stuff.\n        DruidCoordinatorRuntimeParams params =\n                DruidCoordinatorRuntimeParams.newBuilder()\n                        .withStartTime(startTime)\n                        .withDatasources(metadataSegmentManager.getInventory())\n                        .withDynamicConfigs(getDynamicConfigs())\n                        .withEmitter(emitter)\n                        .withBalancerStrategy(balancerStrategy)\n                        .build();\n        for (DruidCoordinatorHelper helper : helpers) {\n          // Don't read state and run state in the same helper otherwise racy conditions may exist\n          if (coordLeaderSelector.isLeader() && startingLeaderCounter == coordLeaderSelector.localTerm()) {\n            params = helper.run(params);\n          }\n        }\n```\n\n在这里，CoordinatorRunnable首先组装出了一个原始的DruidCoordinatorRuntimeParams 对象(后用params代替)，遍历执行了helper中的run方法。这里是使用了装饰器模式，run方法返回的依然是一个params对象，只是对象又进行了一波加工。  \n查看helpers的定义，知道了这是一个`List<DruidCoordinatorHelper>`。该对象的初始化是通过构造器来完成的。想要明白helper做了什么，就需要找到这个类在什么地方被使用，对象是如何创建的。  \n查看类图，如下：  \n![](DruidCoordinator源码分析02.png) \n`CoordinatorRunnable`作为一个抽象类，在工程中并没有方法直接创建`CoordinatorRunnable`对象，也就是说他的run方法是通过子类调用的。有意思的是，`CoordinatorRunnable`被声明成一个抽象类，但是在它的类定义中并没有声明抽象方法。我的印象中，抽象类多用于模板方法模式。但是乍一看这个类并没有使用这一种模式，唯一一个没有确定的方法就是helper的run方法。也就是说，什么样的helper决定了run方法做了什么样的事。helper是通过构造器创建的，而`CoordinatorRunnable`并没有直接通过`new`关键字创建对象，那么其构造器应该只有子类调用。下面到子类中找helper的定义。    \n\n**CoordinatorHistoricalManagerRunnable**  \n这个类继承了`CoordinatorRunnable`抽象类，且只定义了一个有参构造器，就是这个构造器决定了父类的run方法还要做些什么事。   \n\n```java\nsuper(\n          ImmutableList.of(\n              new DruidCoordinatorSegmentInfoLoader(DruidCoordinator.this),\n              new DruidCoordinatorHelper()\n              {\n                @Override\n                public DruidCoordinatorRuntimeParams run(DruidCoordinatorRuntimeParams params)\n                {\n                      ……//省略方法实现\n                }\n              },\n              new DruidCoordinatorRuleRunner(DruidCoordinator.this),\n              new DruidCoordinatorCleanupUnneeded(DruidCoordinator.this),\n              new DruidCoordinatorCleanupOvershadowed(DruidCoordinator.this),\n              new DruidCoordinatorBalancer(DruidCoordinator.this),\n              new DruidCoordinatorLogger(DruidCoordinator.this)\n          ),\n          startingLeaderCounter\n      );\n```\n\n在这个构造器中传入了一个装载`DruidCoordinatorHelper`的列表。这个列表中helper对象会在`DruidCoordinator`的run方法实现中被调用，运行每个helper的run方法。其父类方法的实现中部分步骤延伸至子类，由子类提供实践方式，其实用的还是模板方法。  \n`DruidCoordinatorHelper`并没有继承任何的接口或者类。也就是说`CoordinatorRunnable`的是在单个线程中调用helper的run方法。  \n从这个helper中我们可以看出，这个CoordinatorHistoricalManagerRunnable主要是实现了segments负责均衡以及Rules管理，segments清理等功能。  \n\n**CoordinatorIndexingServiceRunnable**  \n作为`CoordinatorRunnable`的另外一个子类，它的类定义就简单很多了。  \n\n```java\npublic CoordinatorIndexingServiceRunnable(List<DruidCoordinatorHelper> helpers, final int startingLeaderCounter)\n    {\n      super(helpers, startingLeaderCounter);\n    }\n```\n\n这个类中helpers也是通过其构造器赋值的。但是原理是一样的，传什么样的helper就做什么样的事。  \n\n### start()  \n\n该方法由Lifecycle进行管理，注解为`@LifecycleStart`。在Coordinator启动后首先会在同步代码快中判断是Coordinator服务是有已经启动过了(可能配置了HA)，如实没有启动则会去竞争leader。服务是否已经启动  是通过同步状态`started`来表示的。如果当前服务未启动，则将`started`置为`true`，然后就调用`becomeLeader()`方法来完成后续的操作。  \n\n```java\n public void start()\n  {\n    synchronized (lock) {\n      if (started) {\n        return;\n      }\n      started = true;\n\n      coordLeaderSelector.registerListener(\n          new DruidLeaderSelector.Listener()\n          {\n            @Override\n            public void becomeLeader()\n            {\n              DruidCoordinator.this.becomeLeader();\n            }\n\n            @Override\n            public void stopBeingLeader()\n            {\n              DruidCoordinator.this.stopBeingLeader();\n            }\n          }\n      );\n    }\n  }\n```\n\n`Coordiantor`在宣布服务之前会先去对MetadataStorage中的一些元信息进行操作。  \n\n```java\n//扫描segment\n metadataSegmentManager.start();\n//\n metadataRuleManager.start();\n```\n\n**SQLMetadataSegmentManager之start方法**    \n在这个方法中，主要的实现是在这个类的poll()方法中，而poll()方法是通过单个线程调度的，调度方式为`scheduleWithFixedDelay`。通过这种方式调度就必须要等当前的线程工作执行完毕之后，才会在指定的间隔之后进行下一次调度。也就是说单个线程的执行时间对整个的调度周期有较大的影响。  \n这种方式有两个明显的目的: \n1.当前线程的工作不会阻塞主线程的执行，即二者的操作是异步的；  \n2.线程的工作可以周期性的执行。   \n\n因为必须要等当前的线程执行完之后才会进行下一次调度，所以这个地方它创建了只有一个线程的线程池。  \n\n```java\n      //单个线程的线程池\n      exec = Execs.scheduledSingleThreaded(\"DatabaseSegmentManager-Exec--%d\");\n      final Duration delay = config.get().getPollDuration().toStandardDuration();\n     //对单个线程进行调度\n      exec.scheduleWithFixedDelay(\n          new Runnable()\n          {\n            @Override\n            public void run()\n            {\n              readLock.lock();\n              try {\n                if (localStartOrder == currentStartOrder) {\n                  poll();\n                }\n              }\n              catch (Exception e) {\n                log.makeAlert(e, \"uncaught exception in segment manager polling thread\").emit();\n\n              }\n              finally {\n                readLock.unlock();\n              }\n            }\n          },\n          0,\n          delay.getMillis(),\n          TimeUnit.MILLISECONDS\n      );\n```\n\n **SQLMetadataRuleManager之start方法**    \n调度方式与前面的`start()`方法相似，只是`poll()`方法中扫描的数据不一样了。前者是更新`segments`，这里是更新rules。    \n\n完成上述两个操作之后，Coordinator开始宣布服务。  \n宣布服务成功之后，Coordiantor就开始真正执行对segment和历史节点的管理。首先，它创建了一个list，用来存放要干的事以及调度周期。  \n\n```java\nfinal List<Pair<? extends CoordinatorRunnable, Duration>> coordinatorRunnables = Lists.newArrayList();  \n```\n\n在list中Coordinator放入了`CoordinatorRunnable`的两个子类——`CoordinatorHistoricalManagerRunnable`和`CoordinatorIndexingServiceRunnable`。我们先了解一下这个list如何被使用。    \n\n```java\n      for (final Pair<? extends CoordinatorRunnable, Duration> coordinatorRunnable : coordinatorRunnables) {\n        ScheduledExecutors.scheduleWithFixedDelay(\n            exec,\n            config.getCoordinatorStartDelay(),\n            coordinatorRunnable.rhs,\n            new Callable<ScheduledExecutors.Signal>()\n            {\n              private final CoordinatorRunnable theRunnable = coordinatorRunnable.lhs;\n\n              @Override\n              public ScheduledExecutors.Signal call()\n              {\n                if (coordLeaderSelector.isLeader() && startingLeaderCounter == coordLeaderSelector.localTerm()) {\n                  theRunnable.run();\n                }\n                if (coordLeaderSelector.isLeader()\n                    && startingLeaderCounter == coordLeaderSelector.localTerm()) { // (We might no longer be leader)\n                  return ScheduledExecutors.Signal.REPEAT;\n                } else {\n                  return ScheduledExecutors.Signal.STOP;\n                }\n              }\n            }\n        );\n      }\n```\n\n这里也是使用了`scheduleWithFixedDelay`调度，也就是说每个`CoordinatorRunnable`都是要等上一次执行结束之后才会进行下一次的调度。而且这里需要注意到是调度方法中的`exec`变量是一个容量为1的线程池。也就是说这里的调度相当于从主线程又单独创建一个线程来执行这些`CoordinatorRunnable`。这里采用单个线程池的线程进行调度一是为了保证主线程不会阻塞，另外是为确保数据操作的安全性。\n\n至此我们知道了，Coordinator在启动的时候会先尝试去竞争主节点资格，然后扫描元数据库，这里是异步的。接着会宣布服务。服务宣布后他会去将一些工作封装成`CoordinatorRunnable`,由另外**一个**线程去周期性的调度执行这些Runnable的run方法。而这里使用模板方法，在父类的run方法中会调用helper的run方法，而helper是通过子类来确定。  \n所以，为了探究Coordinator接下来会做什么，我们就需要确认在创建其子类对象是，helper是如何实现的。  \n![](DruidCoordinator源码分析03.png)\n\n查看`CoordinatorHistoricalManagerRunnable`的构造器实现：  \n\n```java\n   public CoordinatorHistoricalManagerRunnable(final int startingLeaderCounter)\n    {\n      super(\n          ImmutableList.of(\n              new DruidCoordinatorSegmentInfoLoader(DruidCoordinator.this),\n            //使用匿名内部类创建了一个Helper对象\n              new DruidCoordinatorHelper()\n              {\n                @Override\n                public DruidCoordinatorRuntimeParams run(DruidCoordinatorRuntimeParams params)\n                {\n                  ……//省略方法的实现\n                }\n              },\n              new DruidCoordinatorRuleRunner(DruidCoordinator.this),\n              new DruidCoordinatorCleanupUnneeded(DruidCoordinator.this),\n              new DruidCoordinatorCleanupOvershadowed(DruidCoordinator.this),\n              new DruidCoordinatorBalancer(DruidCoordinator.this),\n              new DruidCoordinatorLogger(DruidCoordinator.this)\n          ),\n          startingLeaderCounter\n      );\n    }\n\n```\n\n查看源码易知，这里实际上是创建了7个`DruidCoordinatorHelper`，我们可以理解成，Coordinator接下来会串行地完成这七件事。这里为了代码的易读性和整洁度，可以把这个匿名内部类拎出来单独实现一下。  \n`CoordinatorHistoricalManagerRunnable`中完成的工作基本上是与segments管理及历史节点负载均衡相关的。具体的实现可以查看每个Runnable的run方法。  \n\n关于`CoordinatorIndexingServiceRunnable`,我们前面说过，它的helpers是通过调用方传入参数决定的。  \n\n```java\n if (indexingServiceClient != null) {\n        coordinatorRunnables.add(\n            Pair.of(\n                new CoordinatorIndexingServiceRunnable(\n                    makeIndexingServiceHelpers(),\n                    startingLeaderCounter\n                ),\n                config.getCoordinatorIndexingPeriod()\n            )\n        );\n\n\n//makeIndexingServiceHelpersde的实现如下： \n\n private List<DruidCoordinatorHelper> makeIndexingServiceHelpers()\n  {\n    List<DruidCoordinatorHelper> helpers = Lists.newArrayList();\n    helpers.add(new DruidCoordinatorSegmentInfoLoader(DruidCoordinator.this));\n    helpers.addAll(indexingServiceHelpers);\n\n    log.info(\"Done making indexing service helpers [%s]\", helpers);\n    return ImmutableList.copyOf(helpers);\n  }\n\n```\n\n实际上是传入了两个helper,一个是`DruidCoordinatorSegmentInfoLoader`,用来加载segments信息。另一个是`indexingServiceHelpers`，负责完成segment的一些合并工作。  \n最后调用`LookupCoordinatorManager`的start()方法，这里暂时先不讨论。  \n\n现在的问题是，列表中的`CoordinatorRunnable`是通过单个线程来进行调度的，而且helpers也是通过串行的方式实现的。那么，如果单次调度时间过长的话，则会导致很长时间后才会进行下一次的调度。  \n这里我们考虑一下，Druid为什么会选择使用只有一个线程资源的线程池来调度所有的`CoordinatorRunnable`。  \n在单个线程中他们实际上是串行的。串行的好处是，在进程中变量对于内存的可见性得到了保证，坏处是执行效率差。\n如果需要对这里进行改造，串行改并行，我们首先要确定的就是共享内存中的变量有哪些，对共享变量的操作有哪些。\n首先查看父类的run方法，再查看run方法调用的各个helper。细看代码我们不难发现，这里其实就是一个装饰器模式。每个help的run方法都会对params对象进行读写，且大部分都是读操作，只有在返回的时候进行了写操作。\n\n 备注：把匿名内部类抽出来，单独实现，然后再作为参数传递，会让代码看起来整洁很多，如下：\n更改前：\n\n```java\n   public CoordinatorHistoricalManagerRunnable(final int startingLeaderCounter)\n    {\n      super(\n          ImmutableList.of(\n              new DruidCoordinatorSegmentInfoLoader(DruidCoordinator.this),\n            //使用匿名内部类创建了一个Helper对象\n              new DruidCoordinatorHelper()\n              {\n                @Override\n                public DruidCoordinatorRuntimeParams run(DruidCoordinatorRuntimeParams params)\n                {\n                  ……//省略方法的实现\n                }\n              },\n              new DruidCoordinatorRuleRunner(DruidCoordinator.this),\n              new DruidCoordinatorCleanupUnneeded(DruidCoordinator.this),\n              new DruidCoordinatorCleanupOvershadowed(DruidCoordinator.this),\n              new DruidCoordinatorBalancer(DruidCoordinator.this),\n              new DruidCoordinatorLogger(DruidCoordinator.this)\n          ),\n          startingLeaderCounter\n      );\n    }\n\n```\n\n更改后： \n\n```java\npublic CoordinatorHistoricalManagerRunnable(final int startingLeaderCounter)\n    {\n      super(\n          ImmutableList.of(\n              new DruidCoordinatorSegmentInfoLoader(DruidCoordinator.this),\n              new DruidCoordinatorPeonRunner(),\n              new DruidCoordinatorRuleRunner(DruidCoordinator.this),\n              new DruidCoordinatorCleanupUnneeded(DruidCoordinator.this),\n              new DruidCoordinatorCleanupOvershadowed(DruidCoordinator.this),\n              new DruidCoordinatorBalancer(DruidCoordinator.this),\n              new DruidCoordinatorLogger(DruidCoordinator.this)\n          ),\n          startingLeaderCounter\n      );\n    }\n\n```\n\n  ","slug":"Coordinator源码分析","published":1,"updated":"2020-03-22T08:17:13.517Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8tjbxtv00046gonmrhn7ds2","content":"<p>Druid Coordinator 服务在整个Druid架构中的主要作用是协调Segments在历史节点之间的分布。其主要功能包括是segments在historical之间分布均衡，rules管理，segments清理合并等等。  </p>\n<a id=\"more\"></a>\n<h2 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h2><blockquote>\n<p>Druid 版本: druid-0.12.3</p>\n</blockquote>\n<p><strong>DruidCoordinator</strong>  </p>\n<p> DruidCoordinator是Coordinator服务的入口，Coordinator启动的流程都是在这个类中开始。首先看一下它的内部类：  </p>\n<p><img src=\"DruidCoordinator源码分析01.png\" alt>  </p>\n<p>DruidCoordinator 一共有三个内部类，即使不看类的定义，我们从类名也可以知道这三个内部类都实现了Runnable接口。在Coordiantor服务中应该是作为三个独立的线程异步执行。<br>我们先大致了解一下每个Runnable的完成的工作。  </p>\n<p><strong>CoordinatorRunnable</strong><br>查看这个类的源码，除了一些判断结构之外，其最主要的实现如下：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Do coordinator stuff.</span></span><br><span class=\"line\">DruidCoordinatorRuntimeParams params =</span><br><span class=\"line\">        DruidCoordinatorRuntimeParams.newBuilder()</span><br><span class=\"line\">                .withStartTime(startTime)</span><br><span class=\"line\">                .withDatasources(metadataSegmentManager.getInventory())</span><br><span class=\"line\">                .withDynamicConfigs(getDynamicConfigs())</span><br><span class=\"line\">                .withEmitter(emitter)</span><br><span class=\"line\">                .withBalancerStrategy(balancerStrategy)</span><br><span class=\"line\">                .build();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (DruidCoordinatorHelper helper : helpers) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Don't read state and run state in the same helper otherwise racy conditions may exist</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (coordLeaderSelector.isLeader() &amp;&amp; startingLeaderCounter == coordLeaderSelector.localTerm()) &#123;</span><br><span class=\"line\">    params = helper.run(params);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这里，CoordinatorRunnable首先组装出了一个原始的DruidCoordinatorRuntimeParams 对象(后用params代替)，遍历执行了helper中的run方法。这里是使用了装饰器模式，run方法返回的依然是一个params对象，只是对象又进行了一波加工。<br>查看helpers的定义，知道了这是一个<code>List&lt;DruidCoordinatorHelper&gt;</code>。该对象的初始化是通过构造器来完成的。想要明白helper做了什么，就需要找到这个类在什么地方被使用，对象是如何创建的。<br>查看类图，如下：<br><img src=\"DruidCoordinator源码分析02.png\" alt><br><code>CoordinatorRunnable</code>作为一个抽象类，在工程中并没有方法直接创建<code>CoordinatorRunnable</code>对象，也就是说他的run方法是通过子类调用的。有意思的是，<code>CoordinatorRunnable</code>被声明成一个抽象类，但是在它的类定义中并没有声明抽象方法。我的印象中，抽象类多用于模板方法模式。但是乍一看这个类并没有使用这一种模式，唯一一个没有确定的方法就是helper的run方法。也就是说，什么样的helper决定了run方法做了什么样的事。helper是通过构造器创建的，而<code>CoordinatorRunnable</code>并没有直接通过<code>new</code>关键字创建对象，那么其构造器应该只有子类调用。下面到子类中找helper的定义。    </p>\n<p><strong>CoordinatorHistoricalManagerRunnable</strong><br>这个类继承了<code>CoordinatorRunnable</code>抽象类，且只定义了一个有参构造器，就是这个构造器决定了父类的run方法还要做些什么事。   </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">super</span>(</span><br><span class=\"line\">          ImmutableList.of(</span><br><span class=\"line\">              <span class=\"keyword\">new</span> DruidCoordinatorSegmentInfoLoader(DruidCoordinator.<span class=\"keyword\">this</span>),</span><br><span class=\"line\">              <span class=\"keyword\">new</span> DruidCoordinatorHelper()</span><br><span class=\"line\">              &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> DruidCoordinatorRuntimeParams <span class=\"title\">run</span><span class=\"params\">(DruidCoordinatorRuntimeParams params)</span></span></span><br><span class=\"line\"><span class=\"function\">                </span>&#123;</span><br><span class=\"line\">                      ……<span class=\"comment\">//省略方法实现</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">              &#125;,</span><br><span class=\"line\">              <span class=\"keyword\">new</span> DruidCoordinatorRuleRunner(DruidCoordinator.<span class=\"keyword\">this</span>),</span><br><span class=\"line\">              <span class=\"keyword\">new</span> DruidCoordinatorCleanupUnneeded(DruidCoordinator.<span class=\"keyword\">this</span>),</span><br><span class=\"line\">              <span class=\"keyword\">new</span> DruidCoordinatorCleanupOvershadowed(DruidCoordinator.<span class=\"keyword\">this</span>),</span><br><span class=\"line\">              <span class=\"keyword\">new</span> DruidCoordinatorBalancer(DruidCoordinator.<span class=\"keyword\">this</span>),</span><br><span class=\"line\">              <span class=\"keyword\">new</span> DruidCoordinatorLogger(DruidCoordinator.<span class=\"keyword\">this</span>)</span><br><span class=\"line\">          ),</span><br><span class=\"line\">          startingLeaderCounter</span><br><span class=\"line\">      );</span><br></pre></td></tr></table></figure>\n<p>在这个构造器中传入了一个装载<code>DruidCoordinatorHelper</code>的列表。这个列表中helper对象会在<code>DruidCoordinator</code>的run方法实现中被调用，运行每个helper的run方法。其父类方法的实现中部分步骤延伸至子类，由子类提供实践方式，其实用的还是模板方法。<br><code>DruidCoordinatorHelper</code>并没有继承任何的接口或者类。也就是说<code>CoordinatorRunnable</code>的是在单个线程中调用helper的run方法。<br>从这个helper中我们可以看出，这个CoordinatorHistoricalManagerRunnable主要是实现了segments负责均衡以及Rules管理，segments清理等功能。  </p>\n<p><strong>CoordinatorIndexingServiceRunnable</strong><br>作为<code>CoordinatorRunnable</code>的另外一个子类，它的类定义就简单很多了。  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CoordinatorIndexingServiceRunnable</span><span class=\"params\">(List&lt;DruidCoordinatorHelper&gt; helpers, <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> startingLeaderCounter)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>(helpers, startingLeaderCounter);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>这个类中helpers也是通过其构造器赋值的。但是原理是一样的，传什么样的helper就做什么样的事。  </p>\n<h3 id=\"start\"><a href=\"#start\" class=\"headerlink\" title=\"start()\"></a>start()</h3><p>该方法由Lifecycle进行管理，注解为<code>@LifecycleStart</code>。在Coordinator启动后首先会在同步代码快中判断是Coordinator服务是有已经启动过了(可能配置了HA)，如实没有启动则会去竞争leader。服务是否已经启动  是通过同步状态<code>started</code>来表示的。如果当前服务未启动，则将<code>started</code>置为<code>true</code>，然后就调用<code>becomeLeader()</code>方法来完成后续的操作。  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">synchronized</span> (lock) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (started) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span>;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     started = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">     coordLeaderSelector.registerListener(</span><br><span class=\"line\">         <span class=\"keyword\">new</span> DruidLeaderSelector.Listener()</span><br><span class=\"line\">         &#123;</span><br><span class=\"line\">           <span class=\"meta\">@Override</span></span><br><span class=\"line\">           <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">becomeLeader</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">           </span>&#123;</span><br><span class=\"line\">             DruidCoordinator.<span class=\"keyword\">this</span>.becomeLeader();</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"meta\">@Override</span></span><br><span class=\"line\">           <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">stopBeingLeader</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">           </span>&#123;</span><br><span class=\"line\">             DruidCoordinator.<span class=\"keyword\">this</span>.stopBeingLeader();</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     );</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p><code>Coordiantor</code>在宣布服务之前会先去对MetadataStorage中的一些元信息进行操作。  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//扫描segment</span></span><br><span class=\"line\"> metadataSegmentManager.start();</span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"> metadataRuleManager.start();</span><br></pre></td></tr></table></figure>\n<p><strong>SQLMetadataSegmentManager之start方法</strong><br>在这个方法中，主要的实现是在这个类的poll()方法中，而poll()方法是通过单个线程调度的，调度方式为<code>scheduleWithFixedDelay</code>。通过这种方式调度就必须要等当前的线程工作执行完毕之后，才会在指定的间隔之后进行下一次调度。也就是说单个线程的执行时间对整个的调度周期有较大的影响。<br>这种方式有两个明显的目的:<br>1.当前线程的工作不会阻塞主线程的执行，即二者的操作是异步的；<br>2.线程的工作可以周期性的执行。   </p>\n<p>因为必须要等当前的线程执行完之后才会进行下一次调度，所以这个地方它创建了只有一个线程的线程池。  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">//单个线程的线程池</span></span><br><span class=\"line\"> exec = Execs.scheduledSingleThreaded(<span class=\"string\">\"DatabaseSegmentManager-Exec--%d\"</span>);</span><br><span class=\"line\"> <span class=\"keyword\">final</span> Duration delay = config.get().getPollDuration().toStandardDuration();</span><br><span class=\"line\"><span class=\"comment\">//对单个线程进行调度</span></span><br><span class=\"line\"> exec.scheduleWithFixedDelay(</span><br><span class=\"line\">     <span class=\"keyword\">new</span> Runnable()</span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">       <span class=\"meta\">@Override</span></span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">       </span>&#123;</span><br><span class=\"line\">         readLock.lock();</span><br><span class=\"line\">         <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (localStartOrder == currentStartOrder) &#123;</span><br><span class=\"line\">             poll();</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">           log.makeAlert(e, <span class=\"string\">\"uncaught exception in segment manager polling thread\"</span>).emit();</span><br><span class=\"line\"></span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">           readLock.unlock();</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">     &#125;,</span><br><span class=\"line\">     <span class=\"number\">0</span>,</span><br><span class=\"line\">     delay.getMillis(),</span><br><span class=\"line\">     TimeUnit.MILLISECONDS</span><br><span class=\"line\"> );</span><br></pre></td></tr></table></figure>\n<p> <strong>SQLMetadataRuleManager之start方法</strong><br>调度方式与前面的<code>start()</code>方法相似，只是<code>poll()</code>方法中扫描的数据不一样了。前者是更新<code>segments</code>，这里是更新rules。    </p>\n<p>完成上述两个操作之后，Coordinator开始宣布服务。<br>宣布服务成功之后，Coordiantor就开始真正执行对segment和历史节点的管理。首先，它创建了一个list，用来存放要干的事以及调度周期。  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> List&lt;Pair&lt;? extends CoordinatorRunnable, Duration&gt;&gt; coordinatorRunnables = Lists.newArrayList();</span><br></pre></td></tr></table></figure>\n<p>在list中Coordinator放入了<code>CoordinatorRunnable</code>的两个子类——<code>CoordinatorHistoricalManagerRunnable</code>和<code>CoordinatorIndexingServiceRunnable</code>。我们先了解一下这个list如何被使用。    </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">final</span> Pair&lt;? extends CoordinatorRunnable, Duration&gt; coordinatorRunnable : coordinatorRunnables) &#123;</span><br><span class=\"line\">  ScheduledExecutors.scheduleWithFixedDelay(</span><br><span class=\"line\">      exec,</span><br><span class=\"line\">      config.getCoordinatorStartDelay(),</span><br><span class=\"line\">      coordinatorRunnable.rhs,</span><br><span class=\"line\">      <span class=\"keyword\">new</span> Callable&lt;ScheduledExecutors.Signal&gt;()</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> CoordinatorRunnable theRunnable = coordinatorRunnable.lhs;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> ScheduledExecutors.<span class=\"function\">Signal <span class=\"title\">call</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">        </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (coordLeaderSelector.isLeader() &amp;&amp; startingLeaderCounter == coordLeaderSelector.localTerm()) &#123;</span><br><span class=\"line\">            theRunnable.run();</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (coordLeaderSelector.isLeader()</span><br><span class=\"line\">              &amp;&amp; startingLeaderCounter == coordLeaderSelector.localTerm()) &#123; <span class=\"comment\">// (We might no longer be leader)</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> ScheduledExecutors.Signal.REPEAT;</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ScheduledExecutors.Signal.STOP;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里也是使用了<code>scheduleWithFixedDelay</code>调度，也就是说每个<code>CoordinatorRunnable</code>都是要等上一次执行结束之后才会进行下一次的调度。而且这里需要注意到是调度方法中的<code>exec</code>变量是一个容量为1的线程池。也就是说这里的调度相当于从主线程又单独创建一个线程来执行这些<code>CoordinatorRunnable</code>。这里采用单个线程池的线程进行调度一是为了保证主线程不会阻塞，另外是为确保数据操作的安全性。</p>\n<p>至此我们知道了，Coordinator在启动的时候会先尝试去竞争主节点资格，然后扫描元数据库，这里是异步的。接着会宣布服务。服务宣布后他会去将一些工作封装成<code>CoordinatorRunnable</code>,由另外<strong>一个</strong>线程去周期性的调度执行这些Runnable的run方法。而这里使用模板方法，在父类的run方法中会调用helper的run方法，而helper是通过子类来确定。<br>所以，为了探究Coordinator接下来会做什么，我们就需要确认在创建其子类对象是，helper是如何实现的。<br><img src=\"DruidCoordinator源码分析03.png\" alt></p>\n<p>查看<code>CoordinatorHistoricalManagerRunnable</code>的构造器实现：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CoordinatorHistoricalManagerRunnable</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> startingLeaderCounter)</span></span></span><br><span class=\"line\"><span class=\"function\"> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">super</span>(</span><br><span class=\"line\">       ImmutableList.of(</span><br><span class=\"line\">           <span class=\"keyword\">new</span> DruidCoordinatorSegmentInfoLoader(DruidCoordinator.<span class=\"keyword\">this</span>),</span><br><span class=\"line\">         <span class=\"comment\">//使用匿名内部类创建了一个Helper对象</span></span><br><span class=\"line\">           <span class=\"keyword\">new</span> DruidCoordinatorHelper()</span><br><span class=\"line\">           &#123;</span><br><span class=\"line\">             <span class=\"meta\">@Override</span></span><br><span class=\"line\">             <span class=\"function\"><span class=\"keyword\">public</span> DruidCoordinatorRuntimeParams <span class=\"title\">run</span><span class=\"params\">(DruidCoordinatorRuntimeParams params)</span></span></span><br><span class=\"line\"><span class=\"function\">             </span>&#123;</span><br><span class=\"line\">               ……<span class=\"comment\">//省略方法的实现</span></span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">           &#125;,</span><br><span class=\"line\">           <span class=\"keyword\">new</span> DruidCoordinatorRuleRunner(DruidCoordinator.<span class=\"keyword\">this</span>),</span><br><span class=\"line\">           <span class=\"keyword\">new</span> DruidCoordinatorCleanupUnneeded(DruidCoordinator.<span class=\"keyword\">this</span>),</span><br><span class=\"line\">           <span class=\"keyword\">new</span> DruidCoordinatorCleanupOvershadowed(DruidCoordinator.<span class=\"keyword\">this</span>),</span><br><span class=\"line\">           <span class=\"keyword\">new</span> DruidCoordinatorBalancer(DruidCoordinator.<span class=\"keyword\">this</span>),</span><br><span class=\"line\">           <span class=\"keyword\">new</span> DruidCoordinatorLogger(DruidCoordinator.<span class=\"keyword\">this</span>)</span><br><span class=\"line\">       ),</span><br><span class=\"line\">       startingLeaderCounter</span><br><span class=\"line\">   );</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>查看源码易知，这里实际上是创建了7个<code>DruidCoordinatorHelper</code>，我们可以理解成，Coordinator接下来会串行地完成这七件事。这里为了代码的易读性和整洁度，可以把这个匿名内部类拎出来单独实现一下。<br><code>CoordinatorHistoricalManagerRunnable</code>中完成的工作基本上是与segments管理及历史节点负载均衡相关的。具体的实现可以查看每个Runnable的run方法。  </p>\n<p>关于<code>CoordinatorIndexingServiceRunnable</code>,我们前面说过，它的helpers是通过调用方传入参数决定的。  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">if</span> (indexingServiceClient != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        coordinatorRunnables.add(</span><br><span class=\"line\">            Pair.of(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> CoordinatorIndexingServiceRunnable(</span><br><span class=\"line\">                    makeIndexingServiceHelpers(),</span><br><span class=\"line\">                    startingLeaderCounter</span><br><span class=\"line\">                ),</span><br><span class=\"line\">                config.getCoordinatorIndexingPeriod()</span><br><span class=\"line\">            )</span><br><span class=\"line\">        );</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//makeIndexingServiceHelpersde的实现如下： </span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">private</span> List&lt;DruidCoordinatorHelper&gt; <span class=\"title\">makeIndexingServiceHelpers</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">    List&lt;DruidCoordinatorHelper&gt; helpers = Lists.newArrayList();</span><br><span class=\"line\">    helpers.add(<span class=\"keyword\">new</span> DruidCoordinatorSegmentInfoLoader(DruidCoordinator.<span class=\"keyword\">this</span>));</span><br><span class=\"line\">    helpers.addAll(indexingServiceHelpers);</span><br><span class=\"line\"></span><br><span class=\"line\">    log.info(<span class=\"string\">\"Done making indexing service helpers [%s]\"</span>, helpers);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ImmutableList.copyOf(helpers);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>实际上是传入了两个helper,一个是<code>DruidCoordinatorSegmentInfoLoader</code>,用来加载segments信息。另一个是<code>indexingServiceHelpers</code>，负责完成segment的一些合并工作。<br>最后调用<code>LookupCoordinatorManager</code>的start()方法，这里暂时先不讨论。  </p>\n<p>现在的问题是，列表中的<code>CoordinatorRunnable</code>是通过单个线程来进行调度的，而且helpers也是通过串行的方式实现的。那么，如果单次调度时间过长的话，则会导致很长时间后才会进行下一次的调度。<br>这里我们考虑一下，Druid为什么会选择使用只有一个线程资源的线程池来调度所有的<code>CoordinatorRunnable</code>。<br>在单个线程中他们实际上是串行的。串行的好处是，在进程中变量对于内存的可见性得到了保证，坏处是执行效率差。<br>如果需要对这里进行改造，串行改并行，我们首先要确定的就是共享内存中的变量有哪些，对共享变量的操作有哪些。<br>首先查看父类的run方法，再查看run方法调用的各个helper。细看代码我们不难发现，这里其实就是一个装饰器模式。每个help的run方法都会对params对象进行读写，且大部分都是读操作，只有在返回的时候进行了写操作。</p>\n<p> 备注：把匿名内部类抽出来，单独实现，然后再作为参数传递，会让代码看起来整洁很多，如下：<br>更改前：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CoordinatorHistoricalManagerRunnable</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> startingLeaderCounter)</span></span></span><br><span class=\"line\"><span class=\"function\"> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">super</span>(</span><br><span class=\"line\">       ImmutableList.of(</span><br><span class=\"line\">           <span class=\"keyword\">new</span> DruidCoordinatorSegmentInfoLoader(DruidCoordinator.<span class=\"keyword\">this</span>),</span><br><span class=\"line\">         <span class=\"comment\">//使用匿名内部类创建了一个Helper对象</span></span><br><span class=\"line\">           <span class=\"keyword\">new</span> DruidCoordinatorHelper()</span><br><span class=\"line\">           &#123;</span><br><span class=\"line\">             <span class=\"meta\">@Override</span></span><br><span class=\"line\">             <span class=\"function\"><span class=\"keyword\">public</span> DruidCoordinatorRuntimeParams <span class=\"title\">run</span><span class=\"params\">(DruidCoordinatorRuntimeParams params)</span></span></span><br><span class=\"line\"><span class=\"function\">             </span>&#123;</span><br><span class=\"line\">               ……<span class=\"comment\">//省略方法的实现</span></span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">           &#125;,</span><br><span class=\"line\">           <span class=\"keyword\">new</span> DruidCoordinatorRuleRunner(DruidCoordinator.<span class=\"keyword\">this</span>),</span><br><span class=\"line\">           <span class=\"keyword\">new</span> DruidCoordinatorCleanupUnneeded(DruidCoordinator.<span class=\"keyword\">this</span>),</span><br><span class=\"line\">           <span class=\"keyword\">new</span> DruidCoordinatorCleanupOvershadowed(DruidCoordinator.<span class=\"keyword\">this</span>),</span><br><span class=\"line\">           <span class=\"keyword\">new</span> DruidCoordinatorBalancer(DruidCoordinator.<span class=\"keyword\">this</span>),</span><br><span class=\"line\">           <span class=\"keyword\">new</span> DruidCoordinatorLogger(DruidCoordinator.<span class=\"keyword\">this</span>)</span><br><span class=\"line\">       ),</span><br><span class=\"line\">       startingLeaderCounter</span><br><span class=\"line\">   );</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>更改后： </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CoordinatorHistoricalManagerRunnable</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> startingLeaderCounter)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>(</span><br><span class=\"line\">          ImmutableList.of(</span><br><span class=\"line\">              <span class=\"keyword\">new</span> DruidCoordinatorSegmentInfoLoader(DruidCoordinator.<span class=\"keyword\">this</span>),</span><br><span class=\"line\">              <span class=\"keyword\">new</span> DruidCoordinatorPeonRunner(),</span><br><span class=\"line\">              <span class=\"keyword\">new</span> DruidCoordinatorRuleRunner(DruidCoordinator.<span class=\"keyword\">this</span>),</span><br><span class=\"line\">              <span class=\"keyword\">new</span> DruidCoordinatorCleanupUnneeded(DruidCoordinator.<span class=\"keyword\">this</span>),</span><br><span class=\"line\">              <span class=\"keyword\">new</span> DruidCoordinatorCleanupOvershadowed(DruidCoordinator.<span class=\"keyword\">this</span>),</span><br><span class=\"line\">              <span class=\"keyword\">new</span> DruidCoordinatorBalancer(DruidCoordinator.<span class=\"keyword\">this</span>),</span><br><span class=\"line\">              <span class=\"keyword\">new</span> DruidCoordinatorLogger(DruidCoordinator.<span class=\"keyword\">this</span>)</span><br><span class=\"line\">          ),</span><br><span class=\"line\">          startingLeaderCounter</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>Druid Coordinator 服务在整个Druid架构中的主要作用是协调Segments在历史节点之间的分布。其主要功能包括是segments在historical之间分布均衡，rules管理，segments清理合并等等。  </p>","more":"<h2 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h2><blockquote>\n<p>Druid 版本: druid-0.12.3</p>\n</blockquote>\n<p><strong>DruidCoordinator</strong>  </p>\n<p> DruidCoordinator是Coordinator服务的入口，Coordinator启动的流程都是在这个类中开始。首先看一下它的内部类：  </p>\n<p><img src=\"DruidCoordinator源码分析01.png\" alt>  </p>\n<p>DruidCoordinator 一共有三个内部类，即使不看类的定义，我们从类名也可以知道这三个内部类都实现了Runnable接口。在Coordiantor服务中应该是作为三个独立的线程异步执行。<br>我们先大致了解一下每个Runnable的完成的工作。  </p>\n<p><strong>CoordinatorRunnable</strong><br>查看这个类的源码，除了一些判断结构之外，其最主要的实现如下：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Do coordinator stuff.</span></span><br><span class=\"line\">DruidCoordinatorRuntimeParams params =</span><br><span class=\"line\">        DruidCoordinatorRuntimeParams.newBuilder()</span><br><span class=\"line\">                .withStartTime(startTime)</span><br><span class=\"line\">                .withDatasources(metadataSegmentManager.getInventory())</span><br><span class=\"line\">                .withDynamicConfigs(getDynamicConfigs())</span><br><span class=\"line\">                .withEmitter(emitter)</span><br><span class=\"line\">                .withBalancerStrategy(balancerStrategy)</span><br><span class=\"line\">                .build();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (DruidCoordinatorHelper helper : helpers) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Don't read state and run state in the same helper otherwise racy conditions may exist</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (coordLeaderSelector.isLeader() &amp;&amp; startingLeaderCounter == coordLeaderSelector.localTerm()) &#123;</span><br><span class=\"line\">    params = helper.run(params);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这里，CoordinatorRunnable首先组装出了一个原始的DruidCoordinatorRuntimeParams 对象(后用params代替)，遍历执行了helper中的run方法。这里是使用了装饰器模式，run方法返回的依然是一个params对象，只是对象又进行了一波加工。<br>查看helpers的定义，知道了这是一个<code>List&lt;DruidCoordinatorHelper&gt;</code>。该对象的初始化是通过构造器来完成的。想要明白helper做了什么，就需要找到这个类在什么地方被使用，对象是如何创建的。<br>查看类图，如下：<br><img src=\"DruidCoordinator源码分析02.png\" alt><br><code>CoordinatorRunnable</code>作为一个抽象类，在工程中并没有方法直接创建<code>CoordinatorRunnable</code>对象，也就是说他的run方法是通过子类调用的。有意思的是，<code>CoordinatorRunnable</code>被声明成一个抽象类，但是在它的类定义中并没有声明抽象方法。我的印象中，抽象类多用于模板方法模式。但是乍一看这个类并没有使用这一种模式，唯一一个没有确定的方法就是helper的run方法。也就是说，什么样的helper决定了run方法做了什么样的事。helper是通过构造器创建的，而<code>CoordinatorRunnable</code>并没有直接通过<code>new</code>关键字创建对象，那么其构造器应该只有子类调用。下面到子类中找helper的定义。    </p>\n<p><strong>CoordinatorHistoricalManagerRunnable</strong><br>这个类继承了<code>CoordinatorRunnable</code>抽象类，且只定义了一个有参构造器，就是这个构造器决定了父类的run方法还要做些什么事。   </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">super</span>(</span><br><span class=\"line\">          ImmutableList.of(</span><br><span class=\"line\">              <span class=\"keyword\">new</span> DruidCoordinatorSegmentInfoLoader(DruidCoordinator.<span class=\"keyword\">this</span>),</span><br><span class=\"line\">              <span class=\"keyword\">new</span> DruidCoordinatorHelper()</span><br><span class=\"line\">              &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> DruidCoordinatorRuntimeParams <span class=\"title\">run</span><span class=\"params\">(DruidCoordinatorRuntimeParams params)</span></span></span><br><span class=\"line\"><span class=\"function\">                </span>&#123;</span><br><span class=\"line\">                      ……<span class=\"comment\">//省略方法实现</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">              &#125;,</span><br><span class=\"line\">              <span class=\"keyword\">new</span> DruidCoordinatorRuleRunner(DruidCoordinator.<span class=\"keyword\">this</span>),</span><br><span class=\"line\">              <span class=\"keyword\">new</span> DruidCoordinatorCleanupUnneeded(DruidCoordinator.<span class=\"keyword\">this</span>),</span><br><span class=\"line\">              <span class=\"keyword\">new</span> DruidCoordinatorCleanupOvershadowed(DruidCoordinator.<span class=\"keyword\">this</span>),</span><br><span class=\"line\">              <span class=\"keyword\">new</span> DruidCoordinatorBalancer(DruidCoordinator.<span class=\"keyword\">this</span>),</span><br><span class=\"line\">              <span class=\"keyword\">new</span> DruidCoordinatorLogger(DruidCoordinator.<span class=\"keyword\">this</span>)</span><br><span class=\"line\">          ),</span><br><span class=\"line\">          startingLeaderCounter</span><br><span class=\"line\">      );</span><br></pre></td></tr></table></figure>\n<p>在这个构造器中传入了一个装载<code>DruidCoordinatorHelper</code>的列表。这个列表中helper对象会在<code>DruidCoordinator</code>的run方法实现中被调用，运行每个helper的run方法。其父类方法的实现中部分步骤延伸至子类，由子类提供实践方式，其实用的还是模板方法。<br><code>DruidCoordinatorHelper</code>并没有继承任何的接口或者类。也就是说<code>CoordinatorRunnable</code>的是在单个线程中调用helper的run方法。<br>从这个helper中我们可以看出，这个CoordinatorHistoricalManagerRunnable主要是实现了segments负责均衡以及Rules管理，segments清理等功能。  </p>\n<p><strong>CoordinatorIndexingServiceRunnable</strong><br>作为<code>CoordinatorRunnable</code>的另外一个子类，它的类定义就简单很多了。  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CoordinatorIndexingServiceRunnable</span><span class=\"params\">(List&lt;DruidCoordinatorHelper&gt; helpers, <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> startingLeaderCounter)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>(helpers, startingLeaderCounter);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>这个类中helpers也是通过其构造器赋值的。但是原理是一样的，传什么样的helper就做什么样的事。  </p>\n<h3 id=\"start\"><a href=\"#start\" class=\"headerlink\" title=\"start()\"></a>start()</h3><p>该方法由Lifecycle进行管理，注解为<code>@LifecycleStart</code>。在Coordinator启动后首先会在同步代码快中判断是Coordinator服务是有已经启动过了(可能配置了HA)，如实没有启动则会去竞争leader。服务是否已经启动  是通过同步状态<code>started</code>来表示的。如果当前服务未启动，则将<code>started</code>置为<code>true</code>，然后就调用<code>becomeLeader()</code>方法来完成后续的操作。  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">synchronized</span> (lock) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (started) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span>;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     started = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">     coordLeaderSelector.registerListener(</span><br><span class=\"line\">         <span class=\"keyword\">new</span> DruidLeaderSelector.Listener()</span><br><span class=\"line\">         &#123;</span><br><span class=\"line\">           <span class=\"meta\">@Override</span></span><br><span class=\"line\">           <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">becomeLeader</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">           </span>&#123;</span><br><span class=\"line\">             DruidCoordinator.<span class=\"keyword\">this</span>.becomeLeader();</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"meta\">@Override</span></span><br><span class=\"line\">           <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">stopBeingLeader</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">           </span>&#123;</span><br><span class=\"line\">             DruidCoordinator.<span class=\"keyword\">this</span>.stopBeingLeader();</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     );</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p><code>Coordiantor</code>在宣布服务之前会先去对MetadataStorage中的一些元信息进行操作。  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//扫描segment</span></span><br><span class=\"line\"> metadataSegmentManager.start();</span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"> metadataRuleManager.start();</span><br></pre></td></tr></table></figure>\n<p><strong>SQLMetadataSegmentManager之start方法</strong><br>在这个方法中，主要的实现是在这个类的poll()方法中，而poll()方法是通过单个线程调度的，调度方式为<code>scheduleWithFixedDelay</code>。通过这种方式调度就必须要等当前的线程工作执行完毕之后，才会在指定的间隔之后进行下一次调度。也就是说单个线程的执行时间对整个的调度周期有较大的影响。<br>这种方式有两个明显的目的:<br>1.当前线程的工作不会阻塞主线程的执行，即二者的操作是异步的；<br>2.线程的工作可以周期性的执行。   </p>\n<p>因为必须要等当前的线程执行完之后才会进行下一次调度，所以这个地方它创建了只有一个线程的线程池。  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">//单个线程的线程池</span></span><br><span class=\"line\"> exec = Execs.scheduledSingleThreaded(<span class=\"string\">\"DatabaseSegmentManager-Exec--%d\"</span>);</span><br><span class=\"line\"> <span class=\"keyword\">final</span> Duration delay = config.get().getPollDuration().toStandardDuration();</span><br><span class=\"line\"><span class=\"comment\">//对单个线程进行调度</span></span><br><span class=\"line\"> exec.scheduleWithFixedDelay(</span><br><span class=\"line\">     <span class=\"keyword\">new</span> Runnable()</span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">       <span class=\"meta\">@Override</span></span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">       </span>&#123;</span><br><span class=\"line\">         readLock.lock();</span><br><span class=\"line\">         <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (localStartOrder == currentStartOrder) &#123;</span><br><span class=\"line\">             poll();</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">           log.makeAlert(e, <span class=\"string\">\"uncaught exception in segment manager polling thread\"</span>).emit();</span><br><span class=\"line\"></span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">           readLock.unlock();</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">     &#125;,</span><br><span class=\"line\">     <span class=\"number\">0</span>,</span><br><span class=\"line\">     delay.getMillis(),</span><br><span class=\"line\">     TimeUnit.MILLISECONDS</span><br><span class=\"line\"> );</span><br></pre></td></tr></table></figure>\n<p> <strong>SQLMetadataRuleManager之start方法</strong><br>调度方式与前面的<code>start()</code>方法相似，只是<code>poll()</code>方法中扫描的数据不一样了。前者是更新<code>segments</code>，这里是更新rules。    </p>\n<p>完成上述两个操作之后，Coordinator开始宣布服务。<br>宣布服务成功之后，Coordiantor就开始真正执行对segment和历史节点的管理。首先，它创建了一个list，用来存放要干的事以及调度周期。  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> List&lt;Pair&lt;? extends CoordinatorRunnable, Duration&gt;&gt; coordinatorRunnables = Lists.newArrayList();</span><br></pre></td></tr></table></figure>\n<p>在list中Coordinator放入了<code>CoordinatorRunnable</code>的两个子类——<code>CoordinatorHistoricalManagerRunnable</code>和<code>CoordinatorIndexingServiceRunnable</code>。我们先了解一下这个list如何被使用。    </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">final</span> Pair&lt;? extends CoordinatorRunnable, Duration&gt; coordinatorRunnable : coordinatorRunnables) &#123;</span><br><span class=\"line\">  ScheduledExecutors.scheduleWithFixedDelay(</span><br><span class=\"line\">      exec,</span><br><span class=\"line\">      config.getCoordinatorStartDelay(),</span><br><span class=\"line\">      coordinatorRunnable.rhs,</span><br><span class=\"line\">      <span class=\"keyword\">new</span> Callable&lt;ScheduledExecutors.Signal&gt;()</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> CoordinatorRunnable theRunnable = coordinatorRunnable.lhs;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> ScheduledExecutors.<span class=\"function\">Signal <span class=\"title\">call</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">        </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (coordLeaderSelector.isLeader() &amp;&amp; startingLeaderCounter == coordLeaderSelector.localTerm()) &#123;</span><br><span class=\"line\">            theRunnable.run();</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (coordLeaderSelector.isLeader()</span><br><span class=\"line\">              &amp;&amp; startingLeaderCounter == coordLeaderSelector.localTerm()) &#123; <span class=\"comment\">// (We might no longer be leader)</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> ScheduledExecutors.Signal.REPEAT;</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ScheduledExecutors.Signal.STOP;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里也是使用了<code>scheduleWithFixedDelay</code>调度，也就是说每个<code>CoordinatorRunnable</code>都是要等上一次执行结束之后才会进行下一次的调度。而且这里需要注意到是调度方法中的<code>exec</code>变量是一个容量为1的线程池。也就是说这里的调度相当于从主线程又单独创建一个线程来执行这些<code>CoordinatorRunnable</code>。这里采用单个线程池的线程进行调度一是为了保证主线程不会阻塞，另外是为确保数据操作的安全性。</p>\n<p>至此我们知道了，Coordinator在启动的时候会先尝试去竞争主节点资格，然后扫描元数据库，这里是异步的。接着会宣布服务。服务宣布后他会去将一些工作封装成<code>CoordinatorRunnable</code>,由另外<strong>一个</strong>线程去周期性的调度执行这些Runnable的run方法。而这里使用模板方法，在父类的run方法中会调用helper的run方法，而helper是通过子类来确定。<br>所以，为了探究Coordinator接下来会做什么，我们就需要确认在创建其子类对象是，helper是如何实现的。<br><img src=\"DruidCoordinator源码分析03.png\" alt></p>\n<p>查看<code>CoordinatorHistoricalManagerRunnable</code>的构造器实现：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CoordinatorHistoricalManagerRunnable</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> startingLeaderCounter)</span></span></span><br><span class=\"line\"><span class=\"function\"> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">super</span>(</span><br><span class=\"line\">       ImmutableList.of(</span><br><span class=\"line\">           <span class=\"keyword\">new</span> DruidCoordinatorSegmentInfoLoader(DruidCoordinator.<span class=\"keyword\">this</span>),</span><br><span class=\"line\">         <span class=\"comment\">//使用匿名内部类创建了一个Helper对象</span></span><br><span class=\"line\">           <span class=\"keyword\">new</span> DruidCoordinatorHelper()</span><br><span class=\"line\">           &#123;</span><br><span class=\"line\">             <span class=\"meta\">@Override</span></span><br><span class=\"line\">             <span class=\"function\"><span class=\"keyword\">public</span> DruidCoordinatorRuntimeParams <span class=\"title\">run</span><span class=\"params\">(DruidCoordinatorRuntimeParams params)</span></span></span><br><span class=\"line\"><span class=\"function\">             </span>&#123;</span><br><span class=\"line\">               ……<span class=\"comment\">//省略方法的实现</span></span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">           &#125;,</span><br><span class=\"line\">           <span class=\"keyword\">new</span> DruidCoordinatorRuleRunner(DruidCoordinator.<span class=\"keyword\">this</span>),</span><br><span class=\"line\">           <span class=\"keyword\">new</span> DruidCoordinatorCleanupUnneeded(DruidCoordinator.<span class=\"keyword\">this</span>),</span><br><span class=\"line\">           <span class=\"keyword\">new</span> DruidCoordinatorCleanupOvershadowed(DruidCoordinator.<span class=\"keyword\">this</span>),</span><br><span class=\"line\">           <span class=\"keyword\">new</span> DruidCoordinatorBalancer(DruidCoordinator.<span class=\"keyword\">this</span>),</span><br><span class=\"line\">           <span class=\"keyword\">new</span> DruidCoordinatorLogger(DruidCoordinator.<span class=\"keyword\">this</span>)</span><br><span class=\"line\">       ),</span><br><span class=\"line\">       startingLeaderCounter</span><br><span class=\"line\">   );</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>查看源码易知，这里实际上是创建了7个<code>DruidCoordinatorHelper</code>，我们可以理解成，Coordinator接下来会串行地完成这七件事。这里为了代码的易读性和整洁度，可以把这个匿名内部类拎出来单独实现一下。<br><code>CoordinatorHistoricalManagerRunnable</code>中完成的工作基本上是与segments管理及历史节点负载均衡相关的。具体的实现可以查看每个Runnable的run方法。  </p>\n<p>关于<code>CoordinatorIndexingServiceRunnable</code>,我们前面说过，它的helpers是通过调用方传入参数决定的。  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">if</span> (indexingServiceClient != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        coordinatorRunnables.add(</span><br><span class=\"line\">            Pair.of(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> CoordinatorIndexingServiceRunnable(</span><br><span class=\"line\">                    makeIndexingServiceHelpers(),</span><br><span class=\"line\">                    startingLeaderCounter</span><br><span class=\"line\">                ),</span><br><span class=\"line\">                config.getCoordinatorIndexingPeriod()</span><br><span class=\"line\">            )</span><br><span class=\"line\">        );</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//makeIndexingServiceHelpersde的实现如下： </span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">private</span> List&lt;DruidCoordinatorHelper&gt; <span class=\"title\">makeIndexingServiceHelpers</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">    List&lt;DruidCoordinatorHelper&gt; helpers = Lists.newArrayList();</span><br><span class=\"line\">    helpers.add(<span class=\"keyword\">new</span> DruidCoordinatorSegmentInfoLoader(DruidCoordinator.<span class=\"keyword\">this</span>));</span><br><span class=\"line\">    helpers.addAll(indexingServiceHelpers);</span><br><span class=\"line\"></span><br><span class=\"line\">    log.info(<span class=\"string\">\"Done making indexing service helpers [%s]\"</span>, helpers);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ImmutableList.copyOf(helpers);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>实际上是传入了两个helper,一个是<code>DruidCoordinatorSegmentInfoLoader</code>,用来加载segments信息。另一个是<code>indexingServiceHelpers</code>，负责完成segment的一些合并工作。<br>最后调用<code>LookupCoordinatorManager</code>的start()方法，这里暂时先不讨论。  </p>\n<p>现在的问题是，列表中的<code>CoordinatorRunnable</code>是通过单个线程来进行调度的，而且helpers也是通过串行的方式实现的。那么，如果单次调度时间过长的话，则会导致很长时间后才会进行下一次的调度。<br>这里我们考虑一下，Druid为什么会选择使用只有一个线程资源的线程池来调度所有的<code>CoordinatorRunnable</code>。<br>在单个线程中他们实际上是串行的。串行的好处是，在进程中变量对于内存的可见性得到了保证，坏处是执行效率差。<br>如果需要对这里进行改造，串行改并行，我们首先要确定的就是共享内存中的变量有哪些，对共享变量的操作有哪些。<br>首先查看父类的run方法，再查看run方法调用的各个helper。细看代码我们不难发现，这里其实就是一个装饰器模式。每个help的run方法都会对params对象进行读写，且大部分都是读操作，只有在返回的时候进行了写操作。</p>\n<p> 备注：把匿名内部类抽出来，单独实现，然后再作为参数传递，会让代码看起来整洁很多，如下：<br>更改前：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CoordinatorHistoricalManagerRunnable</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> startingLeaderCounter)</span></span></span><br><span class=\"line\"><span class=\"function\"> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">super</span>(</span><br><span class=\"line\">       ImmutableList.of(</span><br><span class=\"line\">           <span class=\"keyword\">new</span> DruidCoordinatorSegmentInfoLoader(DruidCoordinator.<span class=\"keyword\">this</span>),</span><br><span class=\"line\">         <span class=\"comment\">//使用匿名内部类创建了一个Helper对象</span></span><br><span class=\"line\">           <span class=\"keyword\">new</span> DruidCoordinatorHelper()</span><br><span class=\"line\">           &#123;</span><br><span class=\"line\">             <span class=\"meta\">@Override</span></span><br><span class=\"line\">             <span class=\"function\"><span class=\"keyword\">public</span> DruidCoordinatorRuntimeParams <span class=\"title\">run</span><span class=\"params\">(DruidCoordinatorRuntimeParams params)</span></span></span><br><span class=\"line\"><span class=\"function\">             </span>&#123;</span><br><span class=\"line\">               ……<span class=\"comment\">//省略方法的实现</span></span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">           &#125;,</span><br><span class=\"line\">           <span class=\"keyword\">new</span> DruidCoordinatorRuleRunner(DruidCoordinator.<span class=\"keyword\">this</span>),</span><br><span class=\"line\">           <span class=\"keyword\">new</span> DruidCoordinatorCleanupUnneeded(DruidCoordinator.<span class=\"keyword\">this</span>),</span><br><span class=\"line\">           <span class=\"keyword\">new</span> DruidCoordinatorCleanupOvershadowed(DruidCoordinator.<span class=\"keyword\">this</span>),</span><br><span class=\"line\">           <span class=\"keyword\">new</span> DruidCoordinatorBalancer(DruidCoordinator.<span class=\"keyword\">this</span>),</span><br><span class=\"line\">           <span class=\"keyword\">new</span> DruidCoordinatorLogger(DruidCoordinator.<span class=\"keyword\">this</span>)</span><br><span class=\"line\">       ),</span><br><span class=\"line\">       startingLeaderCounter</span><br><span class=\"line\">   );</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>更改后： </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CoordinatorHistoricalManagerRunnable</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> startingLeaderCounter)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>(</span><br><span class=\"line\">          ImmutableList.of(</span><br><span class=\"line\">              <span class=\"keyword\">new</span> DruidCoordinatorSegmentInfoLoader(DruidCoordinator.<span class=\"keyword\">this</span>),</span><br><span class=\"line\">              <span class=\"keyword\">new</span> DruidCoordinatorPeonRunner(),</span><br><span class=\"line\">              <span class=\"keyword\">new</span> DruidCoordinatorRuleRunner(DruidCoordinator.<span class=\"keyword\">this</span>),</span><br><span class=\"line\">              <span class=\"keyword\">new</span> DruidCoordinatorCleanupUnneeded(DruidCoordinator.<span class=\"keyword\">this</span>),</span><br><span class=\"line\">              <span class=\"keyword\">new</span> DruidCoordinatorCleanupOvershadowed(DruidCoordinator.<span class=\"keyword\">this</span>),</span><br><span class=\"line\">              <span class=\"keyword\">new</span> DruidCoordinatorBalancer(DruidCoordinator.<span class=\"keyword\">this</span>),</span><br><span class=\"line\">              <span class=\"keyword\">new</span> DruidCoordinatorLogger(DruidCoordinator.<span class=\"keyword\">this</span>)</span><br><span class=\"line\">          ),</span><br><span class=\"line\">          startingLeaderCounter</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>"},{"title":"Java线程池原理","date":"2020-03-23T09:22:54.000Z","_content":"\n池化技术简单来说就是提前准备资源，当需要的时候可以直接获取，避免了在需要大量资源时因创建资源耗时而导致阻塞和过高的时延。常见的有线程池，连接池和内存池。\n\nJava的线程池就是提前创建一定数量的线程，当需要线程处理相应工作的时候直接唤醒获取即可，从而增加系统的处理速度。\n\n<!--more-->\n\n# 1. Java 中ThreadPoolExecutor\n\n## 1.1 ThreadPoolExecutor构造参数说明\n\nJava中常用的线程池类为**ThreadPoolExecutor**，其继承关系如下： \n\n![图片使用starUML绘制](01.png)\n\nExecutor和ExecutorService接口的声明确定了ThreadPoolExecutor有两种方式提交task——execute和submit。二者的区别在于：\n\n* execute：通过execute提交的task之后不会有返回值，提交的task也没有返回值；\n* submit：通过submit提交task之后会返回一个Future对象。获取到这个对象之后，我们可以对提交task进行相应的操作。例如，取消，判断是否结束，阻塞获取task返回的结果等等。\n\n再看ThreadPoolExecutor，这个类有三个构造方法，使用不同的构造方法会对一些参数使用一些缺省设置。这里看一下参数最全的构造方法：\n\n```java\npublic ThreadPoolExecutor(int corePoolSize,\n                          int maximumPoolSize,\n                          long keepAliveTime,\n                          TimeUnit unit,\n                          BlockingQueue<Runnable> workQueue,\n                          ThreadFactory threadFactory,\n                          RejectedExecutionHandler handler)\n```\n\n下面对参数进行一一说明：  \n\n* **int coreSize:** 线程池核心线程数量，这个数量的线程在线程池关闭之前会一直存活；\n\n* **int maximumPoolSize:** 线程最大线程数量，当核心线程被使用完之后，线程池中线程数量可以临时增到这个数量；\n\n* **long keepAliveTime:** 除了核心线程之外，临时增加线程的存活时间，超过这个时间线程就会结束；\n\n* **TimeUnit unit:** keepAliveTime的时间单位；\n\n* **BlockingQueue<Runnable\\> workQueue:** 线程池中的一个阻塞队列，当线程池中线程被使用完之后，提交的task就会被放入这个队列；JUC包中提供的队列主要有以下几种：  \n\n  1. ArrayBlockingQueue： 一个**FIFO**队列，新增加的元素会被追加到集合的尾部。这是一个**有界**的集合，一旦创建其大小就不能够再改变了。往已满队列中追加元素会导致阻塞；\n  2. DelayQueue:  **无界队列**，在放入元素的时候可以指定一个延迟时间，只有当延迟时间结束后，这个元素才能被取出；\n  3. LinkedBlockingQueue：通过不同的构造器可以创建一个**有界或者无界**的队列，队列中的元素**FIFO**；\n  4. PriorityBlockingQueue：**无界队列**，基于优先级实现的队列。集合中的元素按照优先级排序。\n\n* **ThreadFactory threadFactory:** 线程工厂，用来创建线程池中的线程。\n\n* **RejectedExecutionHandler handler:** 线程池的饱和策略，如果线程池中线程被用完了，队列也满了，那么对于新提交的task就会使用这个策略。目前主要有以下几种：\n  1. AbortPolicy：直接抛出异常(默认策略)\n  2. CallerRunsPolicy：调用线程池所在的线程去执行被拒绝的task，会阻塞线程池所在的线程；\n  3. DiscardOldestPolicy：丢弃队列里最久之前的一个任务，并执行当前任务。\n  4. DiscardPolicy：不进行任何处理，直接丢弃掉。\n\n## 1.2 ThreadPoolExecutor 提交流程\n\n### 1.2.1 ThreadPoolExecutor 中的ctl变量\n\n在讨论线程池的提交流程之前，我们需要先把注意力集中到一个特殊的变量上——**ctl**。 ctl是线程池中的控制状态，它是一个原子级别读写的integer，包含两层含义：\n\n* workerCount: 有效线程数；\n* runStat: 线程池的状态，有***Running***，***Shutdown***，***Stop***，***Tidying***，***Terminate***五种状态。\n\n![](02.png)\n\n因为5种状态至少需要3位来表示，剩下的全部用来表示workerCount。所有COUNT_BITS为Interger.SIZE - 3 = 29位。CAPACITY表示的是最大容量，29表示的最大值为2^29 -1,即1 << 29 -1（左移一位相当于乘以2， 1*2^29 -1），二级制表示为`00011111111111111111111111111111`。相当于低29位用来表示容量，高3位留下来表示状态。\n\n五种状态对应的表示分别如下：\n\n* **RUNNING**：`11100000000000000000000000000000`\n\n  running状态下线程池接受新的task，并处理队列中的task\n\n* **SHUTDOWN**：`00000000000000000000000000000000`\n\n  shutdown状态下不会接受新的task，但是会处理队列中的task\n\n* **STOP**：`00100000000000000000000000000000`\n\n  不接受新的task，处理队列中的task，终止正在处理的task\n\n* **TIDYNG**：`01000000000000000000000000000000`\n\n  所有的task结束，workerCount为0，无活跃线程\n\n* **TERMINATED**：`011000000000000000000000000000000`\n\n  terminated()方法执行结束\n\n同时在线程池中还定义了三个方法来对ctl变量进行操作，其中两个是从ctl中获取workerCount和runStart，一个是通过指定的workerCount和runStat生成ctl：\n\n​\t![](03.png)\n\n`runStateOf`和`workerCountOf`都是简单的通过`&`计算将低29为或者高3位置0。而`ctlOf`这是通过 `| `操作将高3位和低29位组合到一起。\n\nctl变量的初始化语句入如下，表示的是running状态，当前worker数为0：\n\n```java\nprivate final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));\n```\n\n### 1.2.2 提交任务流程\n\n通过ThreadPoolExecutor提交任务有两种方式，一种是execute，由他自己实现。另一种是submit，由其父类AbstractExecutorService实现。\n\n这里需要提前说明一些ThreadPoolExecutor类的一些属性：\n\n* workers：HashSet 用来存放线程池worker资源(线程)\n\n* workQueue：BlockingQueue 用来存放用户提交的task(Runnable)\n\n#### 1.2.2.1 通过execute提交task\n\n**execute(Runnable command)方法**\n\n这个方法体比较简短，我就直接全部粘过来了。\n\n![](04.png)\n\n通过代码我们可以看到，最外围的分支结构有三个：\n\n1. 如果线程池的worker数量小于`corePoolSize`,就会添加一个worker，执行当前的task(这里我们先不探究addWorker执行了什么操作)；\n2. 如果第一种情况没有满足(当前wroker数已经达到了corePoolSize大小或者addWorker失败)，就把task添加到阻塞队列中。这个过程成功之后，就会进行一次double-check。\n3. 如果当前worker数量大于coreSize，且队列已满，就会尝试创建一个非核心线程来执行当前task。创建失败的话就会直接使用饱和策略处理task。\n\n> 在double-check的过程中如果发现线程池已经不在运行状态就会把当前task移除，并使用饱和策略处理它。否则就会检查是否有必要创建一些新的线程。\n\n![图片使用Visio绘制](05.png)\n\n\n\n**addWorker(Runnable firstTask, boolean core)方法**\n\n这里的代码分解一下，首先看一下方法的参数列表：  \n\n```java\n private boolean addWorker(Runnable firstTask, boolean core) \n```\n\n这个方法需要传递两个参数，firstTask表示添加的新worker处理的第一个任务，布尔型的core表示添加的是否为核心线程。\n\n跳过线程状态校验的过程，我们直接看这一段：  \n\n```java\nfor (;;) {\n    int wc = workerCountOf(c);\n    if (wc >= CAPACITY ||\n        wc >= (core ? corePoolSize : maximumPoolSize))\n        return false;\n    if (compareAndIncrementWorkerCount(c))\n        break retry;\n    c = ctl.get();  // Re-read ctl\n    if (runStateOf(c) != rs)\n        continue retry;\n}\n```\n\n这里是循环CAS来增加ctl的数值，一旦增加成功，就会正式地创建线程。\n\n线面是创建线程的流程：  \n\n```java\nboolean workerStarted = false;\nboolean workerAdded = false;\nWorker w = null;\ntry {\n    w = new Worker(firstTask);\n    final Thread t = w.thread;\n    if (t != null) {\n        final ReentrantLock mainLock = this.mainLock;\n        mainLock.lock();\n        try {\n            int rs = runStateOf(ctl.get());\n\n            if (rs < SHUTDOWN ||\n                (rs == SHUTDOWN && firstTask == null)) {\n                if (t.isAlive()) \n                    throw new IllegalThreadStateException();\n                workers.add(w);\n                int s = workers.size();\n                if (s > largestPoolSize)\n                    largestPoolSize = s;\n                workerAdded = true;\n            }\n        } finally {\n            mainLock.unlock();\n        }\n        if (workerAdded) {\n            t.start();\n            workerStarted = true;\n        }\n    }\n} finally {\n    if (! workerStarted)\n        addWorkerFailed(w);\n}\nreturn workerStarted;\n```\n\n 这里是直接创建了一个worker对象，而Worker的构造方法如下：  \n\n```java\n        Worker(Runnable firstTask) {\n            setState(-1); \n            this.firstTask = firstTask;\n            this.thread = getThreadFactory().newThread(this);\n        }\n```\n\n可以看到，在构造方法中，Worker创建了一个新的线程作为成员变量。\n\n当一个worker创建之后，还会进行重复校验，已确定worker确实创建成功。\n\n```JAVA\nif (rs < SHUTDOWN ||(rs == SHUTDOWN && firstTask == null)) {\n\tif (t.isAlive()) \n\tthrow new IllegalThreadStateException();\n    workers.add(w);\n    int s = workers.size();\n    if (s > largestPoolSize)\n    largestPoolSize = s;\n    workerAdded = true;\n }\n```\n\n线程创建成功之后，就会启动worker。\n\n```java\n if (workerAdded) {\n\tt.start();\n\tworkerStarted = true;\n}\n```\n\n**Worker**\n\n那么线程池创建了worker线程之后都干些什么呢？如果队列中没有任务要做，线程如何保活呢？如果队列中有worker，线程又会如何去执行呢？为了了解这些，剖析一下Worker的代码就很有必要了。  \n\nThreadPoolExecutor类通过一个HashSet<Worker\\>来存放Worker对象：\n\n `private final HashSet<Worker> workers = new HashSet<Worker>();`\n\n通过Worker的构造器我们看到Worker在构造线程的时候是将自身作为参数传到方法中的，因为其本身也实现了Runnable接口，所以当执行t.start()的时候，实际上执行的是Worker的run()方法。一下是wroker的runWorker方法：\n\n```java\nfinal void runWorker(Worker w) {\n    Thread wt = Thread.currentThread();\n    Runnable task = w.firstTask;\n    w.firstTask = null;\n    w.unlock();\n    boolean completedAbruptly = true;\n    try {\n        while (task != null || (task = getTask()) != null) {\n            w.lock();\n            if ((runStateAtLeast(ctl.get(), STOP) ||\n                 (Thread.interrupted() &&\n                  runStateAtLeast(ctl.get(), STOP))) &&\n                !wt.isInterrupted())\n                wt.interrupt();\n            try {\n                beforeExecute(wt, task);\n                Throwable thrown = null;\n                try {\n                    task.run();\n                } catch (RuntimeException x) {\n                    thrown = x; throw x;\n                } catch (Error x) {\n                    thrown = x; throw x;\n                } catch (Throwable x) {\n                    thrown = x; throw new Error(x);\n                } finally {\n                    afterExecute(task, thrown);\n                }\n            } finally {\n                task = null;\n                w.completedTasks++;\n                w.unlock();\n            }\n        }\n        completedAbruptly = false;\n    } finally {\n        processWorkerExit(w, completedAbruptly);\n    }\n}\n```\n\n粗略地看一下代码，我们知道worker首先会判断自己是否有属于自己的firstTask，如果有的话，就先执行这个task，这里是task.run()，只是普通的方法调用，执行了task的逻辑。当自己的第一个task执行完之后，worker就会进行循环，通过getTask()方法不停地从workerQueue中获取task。这个getTask是个阻塞方法，会一直循环直到返回task或者线程池状态不为running的时刻。\n\n当然，这个getTask()的工作内容不仅仅是返回队列中的task，同时也管理着非核心线程的存活。我们通过参数指定了非核心线程的存活时间，当线程池中有非核心线程且线程空闲的时间超过了指定的时间，就会做掉这些线程。这里它是通过`workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) `这个方式实现，当超过这个等待时间获取到的结果依然为null，表示当前的线程已经空闲了keepAliveTime这么长时间了，属于超时的非核心线程。之后会return null，在worker的runWorker()方法中调用processWorkerExit()方法结束当前worker。\n\n```java\nboolean timed = allowCoreThreadTimeOut || wc > corePoolSize;\n\nif ((wc > maximumPoolSize || (timed && timedOut))\n    && (wc > 1 || workQueue.isEmpty())) {\n    if (compareAndDecrementWorkerCount(c))\n        return null;\n    continue;\n}\n\ntry {\n    Runnable r = timed ?\n        workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :\n        workQueue.take();\n    if (r != null)\n        return r;\n    timedOut = true;\n} catch (InterruptedException retry) {\n    timedOut = false;\n}\n```\n\n\n\n#### 1.2.2.2 通过submit提交task\n\n这个方法是在ThreadPoolExecutor的父类AbstractExecutorService中定义的。AbstractExecutorService是一个抽象类。而submit的逻辑也比较简单：  \n\n![](06.png)\n\n参数的主要区别在于Runnable和Callable，前者无返回值后者有返回值，可以通过Future的get方法阻塞获取。\n\n通过submit提交的task可以获取一个future对象，可以对已提交的task进行相关操作。例如获取返回值或者判断运行状态等等。\n\n可以看到，submit只是将task封装成了一个ftask，然后调用了execute方法调教了这个task到线程池中。这里使用了**模板方法**模式，submit调用的是由子类的线程池实现的execute，也就是上面的execute方法。\n\n# 小结：\n\n关于线程池的构造参数含义和参数的使用逻辑在日常使用过程中还是很值得关注的，对于日后线程池问题定位调优都会有不少的帮助。理解线程池工作原理，线程池中worker的执行流程可以让我们对池化技术和资源利用的看法有更进一步的了解。","source":"_posts/Java线程池原理.md","raw":"---\ntitle: Java线程池原理\ndate: 2020-03-23 17:22:54\ntags:\n - Java\n - 多线程\n - 线程池\ncategories: Java多线程\n\n---\n\n池化技术简单来说就是提前准备资源，当需要的时候可以直接获取，避免了在需要大量资源时因创建资源耗时而导致阻塞和过高的时延。常见的有线程池，连接池和内存池。\n\nJava的线程池就是提前创建一定数量的线程，当需要线程处理相应工作的时候直接唤醒获取即可，从而增加系统的处理速度。\n\n<!--more-->\n\n# 1. Java 中ThreadPoolExecutor\n\n## 1.1 ThreadPoolExecutor构造参数说明\n\nJava中常用的线程池类为**ThreadPoolExecutor**，其继承关系如下： \n\n![图片使用starUML绘制](01.png)\n\nExecutor和ExecutorService接口的声明确定了ThreadPoolExecutor有两种方式提交task——execute和submit。二者的区别在于：\n\n* execute：通过execute提交的task之后不会有返回值，提交的task也没有返回值；\n* submit：通过submit提交task之后会返回一个Future对象。获取到这个对象之后，我们可以对提交task进行相应的操作。例如，取消，判断是否结束，阻塞获取task返回的结果等等。\n\n再看ThreadPoolExecutor，这个类有三个构造方法，使用不同的构造方法会对一些参数使用一些缺省设置。这里看一下参数最全的构造方法：\n\n```java\npublic ThreadPoolExecutor(int corePoolSize,\n                          int maximumPoolSize,\n                          long keepAliveTime,\n                          TimeUnit unit,\n                          BlockingQueue<Runnable> workQueue,\n                          ThreadFactory threadFactory,\n                          RejectedExecutionHandler handler)\n```\n\n下面对参数进行一一说明：  \n\n* **int coreSize:** 线程池核心线程数量，这个数量的线程在线程池关闭之前会一直存活；\n\n* **int maximumPoolSize:** 线程最大线程数量，当核心线程被使用完之后，线程池中线程数量可以临时增到这个数量；\n\n* **long keepAliveTime:** 除了核心线程之外，临时增加线程的存活时间，超过这个时间线程就会结束；\n\n* **TimeUnit unit:** keepAliveTime的时间单位；\n\n* **BlockingQueue<Runnable\\> workQueue:** 线程池中的一个阻塞队列，当线程池中线程被使用完之后，提交的task就会被放入这个队列；JUC包中提供的队列主要有以下几种：  \n\n  1. ArrayBlockingQueue： 一个**FIFO**队列，新增加的元素会被追加到集合的尾部。这是一个**有界**的集合，一旦创建其大小就不能够再改变了。往已满队列中追加元素会导致阻塞；\n  2. DelayQueue:  **无界队列**，在放入元素的时候可以指定一个延迟时间，只有当延迟时间结束后，这个元素才能被取出；\n  3. LinkedBlockingQueue：通过不同的构造器可以创建一个**有界或者无界**的队列，队列中的元素**FIFO**；\n  4. PriorityBlockingQueue：**无界队列**，基于优先级实现的队列。集合中的元素按照优先级排序。\n\n* **ThreadFactory threadFactory:** 线程工厂，用来创建线程池中的线程。\n\n* **RejectedExecutionHandler handler:** 线程池的饱和策略，如果线程池中线程被用完了，队列也满了，那么对于新提交的task就会使用这个策略。目前主要有以下几种：\n  1. AbortPolicy：直接抛出异常(默认策略)\n  2. CallerRunsPolicy：调用线程池所在的线程去执行被拒绝的task，会阻塞线程池所在的线程；\n  3. DiscardOldestPolicy：丢弃队列里最久之前的一个任务，并执行当前任务。\n  4. DiscardPolicy：不进行任何处理，直接丢弃掉。\n\n## 1.2 ThreadPoolExecutor 提交流程\n\n### 1.2.1 ThreadPoolExecutor 中的ctl变量\n\n在讨论线程池的提交流程之前，我们需要先把注意力集中到一个特殊的变量上——**ctl**。 ctl是线程池中的控制状态，它是一个原子级别读写的integer，包含两层含义：\n\n* workerCount: 有效线程数；\n* runStat: 线程池的状态，有***Running***，***Shutdown***，***Stop***，***Tidying***，***Terminate***五种状态。\n\n![](02.png)\n\n因为5种状态至少需要3位来表示，剩下的全部用来表示workerCount。所有COUNT_BITS为Interger.SIZE - 3 = 29位。CAPACITY表示的是最大容量，29表示的最大值为2^29 -1,即1 << 29 -1（左移一位相当于乘以2， 1*2^29 -1），二级制表示为`00011111111111111111111111111111`。相当于低29位用来表示容量，高3位留下来表示状态。\n\n五种状态对应的表示分别如下：\n\n* **RUNNING**：`11100000000000000000000000000000`\n\n  running状态下线程池接受新的task，并处理队列中的task\n\n* **SHUTDOWN**：`00000000000000000000000000000000`\n\n  shutdown状态下不会接受新的task，但是会处理队列中的task\n\n* **STOP**：`00100000000000000000000000000000`\n\n  不接受新的task，处理队列中的task，终止正在处理的task\n\n* **TIDYNG**：`01000000000000000000000000000000`\n\n  所有的task结束，workerCount为0，无活跃线程\n\n* **TERMINATED**：`011000000000000000000000000000000`\n\n  terminated()方法执行结束\n\n同时在线程池中还定义了三个方法来对ctl变量进行操作，其中两个是从ctl中获取workerCount和runStart，一个是通过指定的workerCount和runStat生成ctl：\n\n​\t![](03.png)\n\n`runStateOf`和`workerCountOf`都是简单的通过`&`计算将低29为或者高3位置0。而`ctlOf`这是通过 `| `操作将高3位和低29位组合到一起。\n\nctl变量的初始化语句入如下，表示的是running状态，当前worker数为0：\n\n```java\nprivate final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));\n```\n\n### 1.2.2 提交任务流程\n\n通过ThreadPoolExecutor提交任务有两种方式，一种是execute，由他自己实现。另一种是submit，由其父类AbstractExecutorService实现。\n\n这里需要提前说明一些ThreadPoolExecutor类的一些属性：\n\n* workers：HashSet 用来存放线程池worker资源(线程)\n\n* workQueue：BlockingQueue 用来存放用户提交的task(Runnable)\n\n#### 1.2.2.1 通过execute提交task\n\n**execute(Runnable command)方法**\n\n这个方法体比较简短，我就直接全部粘过来了。\n\n![](04.png)\n\n通过代码我们可以看到，最外围的分支结构有三个：\n\n1. 如果线程池的worker数量小于`corePoolSize`,就会添加一个worker，执行当前的task(这里我们先不探究addWorker执行了什么操作)；\n2. 如果第一种情况没有满足(当前wroker数已经达到了corePoolSize大小或者addWorker失败)，就把task添加到阻塞队列中。这个过程成功之后，就会进行一次double-check。\n3. 如果当前worker数量大于coreSize，且队列已满，就会尝试创建一个非核心线程来执行当前task。创建失败的话就会直接使用饱和策略处理task。\n\n> 在double-check的过程中如果发现线程池已经不在运行状态就会把当前task移除，并使用饱和策略处理它。否则就会检查是否有必要创建一些新的线程。\n\n![图片使用Visio绘制](05.png)\n\n\n\n**addWorker(Runnable firstTask, boolean core)方法**\n\n这里的代码分解一下，首先看一下方法的参数列表：  \n\n```java\n private boolean addWorker(Runnable firstTask, boolean core) \n```\n\n这个方法需要传递两个参数，firstTask表示添加的新worker处理的第一个任务，布尔型的core表示添加的是否为核心线程。\n\n跳过线程状态校验的过程，我们直接看这一段：  \n\n```java\nfor (;;) {\n    int wc = workerCountOf(c);\n    if (wc >= CAPACITY ||\n        wc >= (core ? corePoolSize : maximumPoolSize))\n        return false;\n    if (compareAndIncrementWorkerCount(c))\n        break retry;\n    c = ctl.get();  // Re-read ctl\n    if (runStateOf(c) != rs)\n        continue retry;\n}\n```\n\n这里是循环CAS来增加ctl的数值，一旦增加成功，就会正式地创建线程。\n\n线面是创建线程的流程：  \n\n```java\nboolean workerStarted = false;\nboolean workerAdded = false;\nWorker w = null;\ntry {\n    w = new Worker(firstTask);\n    final Thread t = w.thread;\n    if (t != null) {\n        final ReentrantLock mainLock = this.mainLock;\n        mainLock.lock();\n        try {\n            int rs = runStateOf(ctl.get());\n\n            if (rs < SHUTDOWN ||\n                (rs == SHUTDOWN && firstTask == null)) {\n                if (t.isAlive()) \n                    throw new IllegalThreadStateException();\n                workers.add(w);\n                int s = workers.size();\n                if (s > largestPoolSize)\n                    largestPoolSize = s;\n                workerAdded = true;\n            }\n        } finally {\n            mainLock.unlock();\n        }\n        if (workerAdded) {\n            t.start();\n            workerStarted = true;\n        }\n    }\n} finally {\n    if (! workerStarted)\n        addWorkerFailed(w);\n}\nreturn workerStarted;\n```\n\n 这里是直接创建了一个worker对象，而Worker的构造方法如下：  \n\n```java\n        Worker(Runnable firstTask) {\n            setState(-1); \n            this.firstTask = firstTask;\n            this.thread = getThreadFactory().newThread(this);\n        }\n```\n\n可以看到，在构造方法中，Worker创建了一个新的线程作为成员变量。\n\n当一个worker创建之后，还会进行重复校验，已确定worker确实创建成功。\n\n```JAVA\nif (rs < SHUTDOWN ||(rs == SHUTDOWN && firstTask == null)) {\n\tif (t.isAlive()) \n\tthrow new IllegalThreadStateException();\n    workers.add(w);\n    int s = workers.size();\n    if (s > largestPoolSize)\n    largestPoolSize = s;\n    workerAdded = true;\n }\n```\n\n线程创建成功之后，就会启动worker。\n\n```java\n if (workerAdded) {\n\tt.start();\n\tworkerStarted = true;\n}\n```\n\n**Worker**\n\n那么线程池创建了worker线程之后都干些什么呢？如果队列中没有任务要做，线程如何保活呢？如果队列中有worker，线程又会如何去执行呢？为了了解这些，剖析一下Worker的代码就很有必要了。  \n\nThreadPoolExecutor类通过一个HashSet<Worker\\>来存放Worker对象：\n\n `private final HashSet<Worker> workers = new HashSet<Worker>();`\n\n通过Worker的构造器我们看到Worker在构造线程的时候是将自身作为参数传到方法中的，因为其本身也实现了Runnable接口，所以当执行t.start()的时候，实际上执行的是Worker的run()方法。一下是wroker的runWorker方法：\n\n```java\nfinal void runWorker(Worker w) {\n    Thread wt = Thread.currentThread();\n    Runnable task = w.firstTask;\n    w.firstTask = null;\n    w.unlock();\n    boolean completedAbruptly = true;\n    try {\n        while (task != null || (task = getTask()) != null) {\n            w.lock();\n            if ((runStateAtLeast(ctl.get(), STOP) ||\n                 (Thread.interrupted() &&\n                  runStateAtLeast(ctl.get(), STOP))) &&\n                !wt.isInterrupted())\n                wt.interrupt();\n            try {\n                beforeExecute(wt, task);\n                Throwable thrown = null;\n                try {\n                    task.run();\n                } catch (RuntimeException x) {\n                    thrown = x; throw x;\n                } catch (Error x) {\n                    thrown = x; throw x;\n                } catch (Throwable x) {\n                    thrown = x; throw new Error(x);\n                } finally {\n                    afterExecute(task, thrown);\n                }\n            } finally {\n                task = null;\n                w.completedTasks++;\n                w.unlock();\n            }\n        }\n        completedAbruptly = false;\n    } finally {\n        processWorkerExit(w, completedAbruptly);\n    }\n}\n```\n\n粗略地看一下代码，我们知道worker首先会判断自己是否有属于自己的firstTask，如果有的话，就先执行这个task，这里是task.run()，只是普通的方法调用，执行了task的逻辑。当自己的第一个task执行完之后，worker就会进行循环，通过getTask()方法不停地从workerQueue中获取task。这个getTask是个阻塞方法，会一直循环直到返回task或者线程池状态不为running的时刻。\n\n当然，这个getTask()的工作内容不仅仅是返回队列中的task，同时也管理着非核心线程的存活。我们通过参数指定了非核心线程的存活时间，当线程池中有非核心线程且线程空闲的时间超过了指定的时间，就会做掉这些线程。这里它是通过`workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) `这个方式实现，当超过这个等待时间获取到的结果依然为null，表示当前的线程已经空闲了keepAliveTime这么长时间了，属于超时的非核心线程。之后会return null，在worker的runWorker()方法中调用processWorkerExit()方法结束当前worker。\n\n```java\nboolean timed = allowCoreThreadTimeOut || wc > corePoolSize;\n\nif ((wc > maximumPoolSize || (timed && timedOut))\n    && (wc > 1 || workQueue.isEmpty())) {\n    if (compareAndDecrementWorkerCount(c))\n        return null;\n    continue;\n}\n\ntry {\n    Runnable r = timed ?\n        workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :\n        workQueue.take();\n    if (r != null)\n        return r;\n    timedOut = true;\n} catch (InterruptedException retry) {\n    timedOut = false;\n}\n```\n\n\n\n#### 1.2.2.2 通过submit提交task\n\n这个方法是在ThreadPoolExecutor的父类AbstractExecutorService中定义的。AbstractExecutorService是一个抽象类。而submit的逻辑也比较简单：  \n\n![](06.png)\n\n参数的主要区别在于Runnable和Callable，前者无返回值后者有返回值，可以通过Future的get方法阻塞获取。\n\n通过submit提交的task可以获取一个future对象，可以对已提交的task进行相关操作。例如获取返回值或者判断运行状态等等。\n\n可以看到，submit只是将task封装成了一个ftask，然后调用了execute方法调教了这个task到线程池中。这里使用了**模板方法**模式，submit调用的是由子类的线程池实现的execute，也就是上面的execute方法。\n\n# 小结：\n\n关于线程池的构造参数含义和参数的使用逻辑在日常使用过程中还是很值得关注的，对于日后线程池问题定位调优都会有不少的帮助。理解线程池工作原理，线程池中worker的执行流程可以让我们对池化技术和资源利用的看法有更进一步的了解。","slug":"Java线程池原理","published":1,"updated":"2020-03-24T07:49:34.527Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8tjbxtw00056gonyxmqziat","content":"<p>池化技术简单来说就是提前准备资源，当需要的时候可以直接获取，避免了在需要大量资源时因创建资源耗时而导致阻塞和过高的时延。常见的有线程池，连接池和内存池。</p>\n<p>Java的线程池就是提前创建一定数量的线程，当需要线程处理相应工作的时候直接唤醒获取即可，从而增加系统的处理速度。</p>\n<a id=\"more\"></a>\n<h1 id=\"1-Java-中ThreadPoolExecutor\"><a href=\"#1-Java-中ThreadPoolExecutor\" class=\"headerlink\" title=\"1. Java 中ThreadPoolExecutor\"></a>1. Java 中ThreadPoolExecutor</h1><h2 id=\"1-1-ThreadPoolExecutor构造参数说明\"><a href=\"#1-1-ThreadPoolExecutor构造参数说明\" class=\"headerlink\" title=\"1.1 ThreadPoolExecutor构造参数说明\"></a>1.1 ThreadPoolExecutor构造参数说明</h2><p>Java中常用的线程池类为<strong>ThreadPoolExecutor</strong>，其继承关系如下： </p>\n<p><img src=\"01.png\" alt=\"图片使用starUML绘制\"></p>\n<p>Executor和ExecutorService接口的声明确定了ThreadPoolExecutor有两种方式提交task——execute和submit。二者的区别在于：</p>\n<ul>\n<li>execute：通过execute提交的task之后不会有返回值，提交的task也没有返回值；</li>\n<li>submit：通过submit提交task之后会返回一个Future对象。获取到这个对象之后，我们可以对提交task进行相应的操作。例如，取消，判断是否结束，阻塞获取task返回的结果等等。</li>\n</ul>\n<p>再看ThreadPoolExecutor，这个类有三个构造方法，使用不同的构造方法会对一些参数使用一些缺省设置。这里看一下参数最全的构造方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ThreadPoolExecutor</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          <span class=\"keyword\">int</span> maximumPoolSize,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          <span class=\"keyword\">long</span> keepAliveTime,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          TimeUnit unit,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          ThreadFactory threadFactory,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure>\n<p>下面对参数进行一一说明：  </p>\n<ul>\n<li><p><strong>int coreSize:</strong> 线程池核心线程数量，这个数量的线程在线程池关闭之前会一直存活；</p>\n</li>\n<li><p><strong>int maximumPoolSize:</strong> 线程最大线程数量，当核心线程被使用完之后，线程池中线程数量可以临时增到这个数量；</p>\n</li>\n<li><p><strong>long keepAliveTime:</strong> 除了核心线程之外，临时增加线程的存活时间，超过这个时间线程就会结束；</p>\n</li>\n<li><p><strong>TimeUnit unit:</strong> keepAliveTime的时间单位；</p>\n</li>\n<li><p><strong>BlockingQueue&lt;Runnable> workQueue:</strong> 线程池中的一个阻塞队列，当线程池中线程被使用完之后，提交的task就会被放入这个队列；JUC包中提供的队列主要有以下几种：  </p>\n<ol>\n<li>ArrayBlockingQueue： 一个<strong>FIFO</strong>队列，新增加的元素会被追加到集合的尾部。这是一个<strong>有界</strong>的集合，一旦创建其大小就不能够再改变了。往已满队列中追加元素会导致阻塞；</li>\n<li>DelayQueue:  <strong>无界队列</strong>，在放入元素的时候可以指定一个延迟时间，只有当延迟时间结束后，这个元素才能被取出；</li>\n<li>LinkedBlockingQueue：通过不同的构造器可以创建一个<strong>有界或者无界</strong>的队列，队列中的元素<strong>FIFO</strong>；</li>\n<li>PriorityBlockingQueue：<strong>无界队列</strong>，基于优先级实现的队列。集合中的元素按照优先级排序。</li>\n</ol>\n</li>\n<li><p><strong>ThreadFactory threadFactory:</strong> 线程工厂，用来创建线程池中的线程。</p>\n</li>\n<li><p><strong>RejectedExecutionHandler handler:</strong> 线程池的饱和策略，如果线程池中线程被用完了，队列也满了，那么对于新提交的task就会使用这个策略。目前主要有以下几种：</p>\n<ol>\n<li>AbortPolicy：直接抛出异常(默认策略)</li>\n<li>CallerRunsPolicy：调用线程池所在的线程去执行被拒绝的task，会阻塞线程池所在的线程；</li>\n<li>DiscardOldestPolicy：丢弃队列里最久之前的一个任务，并执行当前任务。</li>\n<li>DiscardPolicy：不进行任何处理，直接丢弃掉。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"1-2-ThreadPoolExecutor-提交流程\"><a href=\"#1-2-ThreadPoolExecutor-提交流程\" class=\"headerlink\" title=\"1.2 ThreadPoolExecutor 提交流程\"></a>1.2 ThreadPoolExecutor 提交流程</h2><h3 id=\"1-2-1-ThreadPoolExecutor-中的ctl变量\"><a href=\"#1-2-1-ThreadPoolExecutor-中的ctl变量\" class=\"headerlink\" title=\"1.2.1 ThreadPoolExecutor 中的ctl变量\"></a>1.2.1 ThreadPoolExecutor 中的ctl变量</h3><p>在讨论线程池的提交流程之前，我们需要先把注意力集中到一个特殊的变量上——<strong>ctl</strong>。 ctl是线程池中的控制状态，它是一个原子级别读写的integer，包含两层含义：</p>\n<ul>\n<li>workerCount: 有效线程数；</li>\n<li>runStat: 线程池的状态，有<strong><em>Running</em></strong>，<strong><em>Shutdown</em></strong>，<strong><em>Stop</em></strong>，<strong><em>Tidying</em></strong>，<strong><em>Terminate</em></strong>五种状态。</li>\n</ul>\n<p><img src=\"02.png\" alt></p>\n<p>因为5种状态至少需要3位来表示，剩下的全部用来表示workerCount。所有COUNT_BITS为Interger.SIZE - 3 = 29位。CAPACITY表示的是最大容量，29表示的最大值为2^29 -1,即1 &lt;&lt; 29 -1（左移一位相当于乘以2， 1*2^29 -1），二级制表示为<code>00011111111111111111111111111111</code>。相当于低29位用来表示容量，高3位留下来表示状态。</p>\n<p>五种状态对应的表示分别如下：</p>\n<ul>\n<li><p><strong>RUNNING</strong>：<code>11100000000000000000000000000000</code></p>\n<p>running状态下线程池接受新的task，并处理队列中的task</p>\n</li>\n<li><p><strong>SHUTDOWN</strong>：<code>00000000000000000000000000000000</code></p>\n<p>shutdown状态下不会接受新的task，但是会处理队列中的task</p>\n</li>\n<li><p><strong>STOP</strong>：<code>00100000000000000000000000000000</code></p>\n<p>不接受新的task，处理队列中的task，终止正在处理的task</p>\n</li>\n<li><p><strong>TIDYNG</strong>：<code>01000000000000000000000000000000</code></p>\n<p>所有的task结束，workerCount为0，无活跃线程</p>\n</li>\n<li><p><strong>TERMINATED</strong>：<code>011000000000000000000000000000000</code></p>\n<p>terminated()方法执行结束</p>\n</li>\n</ul>\n<p>同时在线程池中还定义了三个方法来对ctl变量进行操作，其中两个是从ctl中获取workerCount和runStart，一个是通过指定的workerCount和runStat生成ctl：</p>\n<p>​    <img src=\"03.png\" alt></p>\n<p><code>runStateOf</code>和<code>workerCountOf</code>都是简单的通过<code>&amp;</code>计算将低29为或者高3位置0。而<code>ctlOf</code>这是通过 <code>|</code>操作将高3位和低29位组合到一起。</p>\n<p>ctl变量的初始化语句入如下，表示的是running状态，当前worker数为0：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AtomicInteger ctl = <span class=\"keyword\">new</span> AtomicInteger(ctlOf(RUNNING, <span class=\"number\">0</span>));</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-2-2-提交任务流程\"><a href=\"#1-2-2-提交任务流程\" class=\"headerlink\" title=\"1.2.2 提交任务流程\"></a>1.2.2 提交任务流程</h3><p>通过ThreadPoolExecutor提交任务有两种方式，一种是execute，由他自己实现。另一种是submit，由其父类AbstractExecutorService实现。</p>\n<p>这里需要提前说明一些ThreadPoolExecutor类的一些属性：</p>\n<ul>\n<li><p>workers：HashSet 用来存放线程池worker资源(线程)</p>\n</li>\n<li><p>workQueue：BlockingQueue 用来存放用户提交的task(Runnable)</p>\n</li>\n</ul>\n<h4 id=\"1-2-2-1-通过execute提交task\"><a href=\"#1-2-2-1-通过execute提交task\" class=\"headerlink\" title=\"1.2.2.1 通过execute提交task\"></a>1.2.2.1 通过execute提交task</h4><p><strong>execute(Runnable command)方法</strong></p>\n<p>这个方法体比较简短，我就直接全部粘过来了。</p>\n<p><img src=\"04.png\" alt></p>\n<p>通过代码我们可以看到，最外围的分支结构有三个：</p>\n<ol>\n<li>如果线程池的worker数量小于<code>corePoolSize</code>,就会添加一个worker，执行当前的task(这里我们先不探究addWorker执行了什么操作)；</li>\n<li>如果第一种情况没有满足(当前wroker数已经达到了corePoolSize大小或者addWorker失败)，就把task添加到阻塞队列中。这个过程成功之后，就会进行一次double-check。</li>\n<li>如果当前worker数量大于coreSize，且队列已满，就会尝试创建一个非核心线程来执行当前task。创建失败的话就会直接使用饱和策略处理task。</li>\n</ol>\n<blockquote>\n<p>在double-check的过程中如果发现线程池已经不在运行状态就会把当前task移除，并使用饱和策略处理它。否则就会检查是否有必要创建一些新的线程。</p>\n</blockquote>\n<p><img src=\"05.png\" alt=\"图片使用Visio绘制\"></p>\n<p><strong>addWorker(Runnable firstTask, boolean core)方法</strong></p>\n<p>这里的代码分解一下，首先看一下方法的参数列表：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addWorker</span><span class=\"params\">(Runnable firstTask, <span class=\"keyword\">boolean</span> core)</span></span></span><br></pre></td></tr></table></figure>\n<p>这个方法需要传递两个参数，firstTask表示添加的新worker处理的第一个任务，布尔型的core表示添加的是否为核心线程。</p>\n<p>跳过线程状态校验的过程，我们直接看这一段：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> wc = workerCountOf(c);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (wc &gt;= CAPACITY ||</span><br><span class=\"line\">        wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class=\"line\">        <span class=\"keyword\">break</span> retry;</span><br><span class=\"line\">    c = ctl.get();  <span class=\"comment\">// Re-read ctl</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (runStateOf(c) != rs)</span><br><span class=\"line\">        <span class=\"keyword\">continue</span> retry;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里是循环CAS来增加ctl的数值，一旦增加成功，就会正式地创建线程。</p>\n<p>线面是创建线程的流程：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">boolean</span> workerStarted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"><span class=\"keyword\">boolean</span> workerAdded = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">Worker w = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    w = <span class=\"keyword\">new</span> Worker(firstTask);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Thread t = w.thread;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (t != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> ReentrantLock mainLock = <span class=\"keyword\">this</span>.mainLock;</span><br><span class=\"line\">        mainLock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> rs = runStateOf(ctl.get());</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (rs &lt; SHUTDOWN ||</span><br><span class=\"line\">                (rs == SHUTDOWN &amp;&amp; firstTask == <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (t.isAlive()) </span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalThreadStateException();</span><br><span class=\"line\">                workers.add(w);</span><br><span class=\"line\">                <span class=\"keyword\">int</span> s = workers.size();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (s &gt; largestPoolSize)</span><br><span class=\"line\">                    largestPoolSize = s;</span><br><span class=\"line\">                workerAdded = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            mainLock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (workerAdded) &#123;</span><br><span class=\"line\">            t.start();</span><br><span class=\"line\">            workerStarted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (! workerStarted)</span><br><span class=\"line\">        addWorkerFailed(w);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> workerStarted;</span><br></pre></td></tr></table></figure>\n<p> 这里是直接创建了一个worker对象，而Worker的构造方法如下：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Worker(Runnable firstTask) &#123;</span><br><span class=\"line\">    setState(-<span class=\"number\">1</span>); </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.firstTask = firstTask;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.thread = getThreadFactory().newThread(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，在构造方法中，Worker创建了一个新的线程作为成员变量。</p>\n<p>当一个worker创建之后，还会进行重复校验，已确定worker确实创建成功。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (rs &lt; SHUTDOWN ||(rs == SHUTDOWN &amp;&amp; firstTask == <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (t.isAlive()) </span><br><span class=\"line\">\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalThreadStateException();</span><br><span class=\"line\">    workers.add(w);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> s = workers.size();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s &gt; largestPoolSize)</span><br><span class=\"line\">    largestPoolSize = s;</span><br><span class=\"line\">    workerAdded = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>线程创建成功之后，就会启动worker。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">if</span> (workerAdded) &#123;</span><br><span class=\"line\">\tt.start();</span><br><span class=\"line\">\tworkerStarted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>Worker</strong></p>\n<p>那么线程池创建了worker线程之后都干些什么呢？如果队列中没有任务要做，线程如何保活呢？如果队列中有worker，线程又会如何去执行呢？为了了解这些，剖析一下Worker的代码就很有必要了。  </p>\n<p>ThreadPoolExecutor类通过一个HashSet&lt;Worker>来存放Worker对象：</p>\n<p> <code>private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;();</code></p>\n<p>通过Worker的构造器我们看到Worker在构造线程的时候是将自身作为参数传到方法中的，因为其本身也实现了Runnable接口，所以当执行t.start()的时候，实际上执行的是Worker的run()方法。一下是wroker的runWorker方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">runWorker</span><span class=\"params\">(Worker w)</span> </span>&#123;</span><br><span class=\"line\">    Thread wt = Thread.currentThread();</span><br><span class=\"line\">    Runnable task = w.firstTask;</span><br><span class=\"line\">    w.firstTask = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    w.unlock();</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> completedAbruptly = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (task != <span class=\"keyword\">null</span> || (task = getTask()) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            w.lock();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class=\"line\">                 (Thread.interrupted() &amp;&amp;</span><br><span class=\"line\">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class=\"line\">                !wt.isInterrupted())</span><br><span class=\"line\">                wt.interrupt();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                beforeExecute(wt, task);</span><br><span class=\"line\">                Throwable thrown = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    task.run();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (RuntimeException x) &#123;</span><br><span class=\"line\">                    thrown = x; <span class=\"keyword\">throw</span> x;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Error x) &#123;</span><br><span class=\"line\">                    thrown = x; <span class=\"keyword\">throw</span> x;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Throwable x) &#123;</span><br><span class=\"line\">                    thrown = x; <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(x);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    afterExecute(task, thrown);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                task = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                w.completedTasks++;</span><br><span class=\"line\">                w.unlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        completedAbruptly = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        processWorkerExit(w, completedAbruptly);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>粗略地看一下代码，我们知道worker首先会判断自己是否有属于自己的firstTask，如果有的话，就先执行这个task，这里是task.run()，只是普通的方法调用，执行了task的逻辑。当自己的第一个task执行完之后，worker就会进行循环，通过getTask()方法不停地从workerQueue中获取task。这个getTask是个阻塞方法，会一直循环直到返回task或者线程池状态不为running的时刻。</p>\n<p>当然，这个getTask()的工作内容不仅仅是返回队列中的task，同时也管理着非核心线程的存活。我们通过参数指定了非核心线程的存活时间，当线程池中有非核心线程且线程空闲的时间超过了指定的时间，就会做掉这些线程。这里它是通过<code>workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS)</code>这个方式实现，当超过这个等待时间获取到的结果依然为null，表示当前的线程已经空闲了keepAliveTime这么长时间了，属于超时的非核心线程。之后会return null，在worker的runWorker()方法中调用processWorkerExit()方法结束当前worker。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class=\"line\">    &amp;&amp; (wc &gt; <span class=\"number\">1</span> || workQueue.isEmpty())) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    Runnable r = timed ?</span><br><span class=\"line\">        workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class=\"line\">        workQueue.take();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (r != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">    timedOut = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (InterruptedException retry) &#123;</span><br><span class=\"line\">    timedOut = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"1-2-2-2-通过submit提交task\"><a href=\"#1-2-2-2-通过submit提交task\" class=\"headerlink\" title=\"1.2.2.2 通过submit提交task\"></a>1.2.2.2 通过submit提交task</h4><p>这个方法是在ThreadPoolExecutor的父类AbstractExecutorService中定义的。AbstractExecutorService是一个抽象类。而submit的逻辑也比较简单：  </p>\n<p><img src=\"06.png\" alt></p>\n<p>参数的主要区别在于Runnable和Callable，前者无返回值后者有返回值，可以通过Future的get方法阻塞获取。</p>\n<p>通过submit提交的task可以获取一个future对象，可以对已提交的task进行相关操作。例如获取返回值或者判断运行状态等等。</p>\n<p>可以看到，submit只是将task封装成了一个ftask，然后调用了execute方法调教了这个task到线程池中。这里使用了<strong>模板方法</strong>模式，submit调用的是由子类的线程池实现的execute，也就是上面的execute方法。</p>\n<h1 id=\"小结：\"><a href=\"#小结：\" class=\"headerlink\" title=\"小结：\"></a>小结：</h1><p>关于线程池的构造参数含义和参数的使用逻辑在日常使用过程中还是很值得关注的，对于日后线程池问题定位调优都会有不少的帮助。理解线程池工作原理，线程池中worker的执行流程可以让我们对池化技术和资源利用的看法有更进一步的了解。</p>\n","site":{"data":{}},"excerpt":"<p>池化技术简单来说就是提前准备资源，当需要的时候可以直接获取，避免了在需要大量资源时因创建资源耗时而导致阻塞和过高的时延。常见的有线程池，连接池和内存池。</p>\n<p>Java的线程池就是提前创建一定数量的线程，当需要线程处理相应工作的时候直接唤醒获取即可，从而增加系统的处理速度。</p>","more":"<h1 id=\"1-Java-中ThreadPoolExecutor\"><a href=\"#1-Java-中ThreadPoolExecutor\" class=\"headerlink\" title=\"1. Java 中ThreadPoolExecutor\"></a>1. Java 中ThreadPoolExecutor</h1><h2 id=\"1-1-ThreadPoolExecutor构造参数说明\"><a href=\"#1-1-ThreadPoolExecutor构造参数说明\" class=\"headerlink\" title=\"1.1 ThreadPoolExecutor构造参数说明\"></a>1.1 ThreadPoolExecutor构造参数说明</h2><p>Java中常用的线程池类为<strong>ThreadPoolExecutor</strong>，其继承关系如下： </p>\n<p><img src=\"01.png\" alt=\"图片使用starUML绘制\"></p>\n<p>Executor和ExecutorService接口的声明确定了ThreadPoolExecutor有两种方式提交task——execute和submit。二者的区别在于：</p>\n<ul>\n<li>execute：通过execute提交的task之后不会有返回值，提交的task也没有返回值；</li>\n<li>submit：通过submit提交task之后会返回一个Future对象。获取到这个对象之后，我们可以对提交task进行相应的操作。例如，取消，判断是否结束，阻塞获取task返回的结果等等。</li>\n</ul>\n<p>再看ThreadPoolExecutor，这个类有三个构造方法，使用不同的构造方法会对一些参数使用一些缺省设置。这里看一下参数最全的构造方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ThreadPoolExecutor</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          <span class=\"keyword\">int</span> maximumPoolSize,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          <span class=\"keyword\">long</span> keepAliveTime,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          TimeUnit unit,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          ThreadFactory threadFactory,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure>\n<p>下面对参数进行一一说明：  </p>\n<ul>\n<li><p><strong>int coreSize:</strong> 线程池核心线程数量，这个数量的线程在线程池关闭之前会一直存活；</p>\n</li>\n<li><p><strong>int maximumPoolSize:</strong> 线程最大线程数量，当核心线程被使用完之后，线程池中线程数量可以临时增到这个数量；</p>\n</li>\n<li><p><strong>long keepAliveTime:</strong> 除了核心线程之外，临时增加线程的存活时间，超过这个时间线程就会结束；</p>\n</li>\n<li><p><strong>TimeUnit unit:</strong> keepAliveTime的时间单位；</p>\n</li>\n<li><p><strong>BlockingQueue&lt;Runnable> workQueue:</strong> 线程池中的一个阻塞队列，当线程池中线程被使用完之后，提交的task就会被放入这个队列；JUC包中提供的队列主要有以下几种：  </p>\n<ol>\n<li>ArrayBlockingQueue： 一个<strong>FIFO</strong>队列，新增加的元素会被追加到集合的尾部。这是一个<strong>有界</strong>的集合，一旦创建其大小就不能够再改变了。往已满队列中追加元素会导致阻塞；</li>\n<li>DelayQueue:  <strong>无界队列</strong>，在放入元素的时候可以指定一个延迟时间，只有当延迟时间结束后，这个元素才能被取出；</li>\n<li>LinkedBlockingQueue：通过不同的构造器可以创建一个<strong>有界或者无界</strong>的队列，队列中的元素<strong>FIFO</strong>；</li>\n<li>PriorityBlockingQueue：<strong>无界队列</strong>，基于优先级实现的队列。集合中的元素按照优先级排序。</li>\n</ol>\n</li>\n<li><p><strong>ThreadFactory threadFactory:</strong> 线程工厂，用来创建线程池中的线程。</p>\n</li>\n<li><p><strong>RejectedExecutionHandler handler:</strong> 线程池的饱和策略，如果线程池中线程被用完了，队列也满了，那么对于新提交的task就会使用这个策略。目前主要有以下几种：</p>\n<ol>\n<li>AbortPolicy：直接抛出异常(默认策略)</li>\n<li>CallerRunsPolicy：调用线程池所在的线程去执行被拒绝的task，会阻塞线程池所在的线程；</li>\n<li>DiscardOldestPolicy：丢弃队列里最久之前的一个任务，并执行当前任务。</li>\n<li>DiscardPolicy：不进行任何处理，直接丢弃掉。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"1-2-ThreadPoolExecutor-提交流程\"><a href=\"#1-2-ThreadPoolExecutor-提交流程\" class=\"headerlink\" title=\"1.2 ThreadPoolExecutor 提交流程\"></a>1.2 ThreadPoolExecutor 提交流程</h2><h3 id=\"1-2-1-ThreadPoolExecutor-中的ctl变量\"><a href=\"#1-2-1-ThreadPoolExecutor-中的ctl变量\" class=\"headerlink\" title=\"1.2.1 ThreadPoolExecutor 中的ctl变量\"></a>1.2.1 ThreadPoolExecutor 中的ctl变量</h3><p>在讨论线程池的提交流程之前，我们需要先把注意力集中到一个特殊的变量上——<strong>ctl</strong>。 ctl是线程池中的控制状态，它是一个原子级别读写的integer，包含两层含义：</p>\n<ul>\n<li>workerCount: 有效线程数；</li>\n<li>runStat: 线程池的状态，有<strong><em>Running</em></strong>，<strong><em>Shutdown</em></strong>，<strong><em>Stop</em></strong>，<strong><em>Tidying</em></strong>，<strong><em>Terminate</em></strong>五种状态。</li>\n</ul>\n<p><img src=\"02.png\" alt></p>\n<p>因为5种状态至少需要3位来表示，剩下的全部用来表示workerCount。所有COUNT_BITS为Interger.SIZE - 3 = 29位。CAPACITY表示的是最大容量，29表示的最大值为2^29 -1,即1 &lt;&lt; 29 -1（左移一位相当于乘以2， 1*2^29 -1），二级制表示为<code>00011111111111111111111111111111</code>。相当于低29位用来表示容量，高3位留下来表示状态。</p>\n<p>五种状态对应的表示分别如下：</p>\n<ul>\n<li><p><strong>RUNNING</strong>：<code>11100000000000000000000000000000</code></p>\n<p>running状态下线程池接受新的task，并处理队列中的task</p>\n</li>\n<li><p><strong>SHUTDOWN</strong>：<code>00000000000000000000000000000000</code></p>\n<p>shutdown状态下不会接受新的task，但是会处理队列中的task</p>\n</li>\n<li><p><strong>STOP</strong>：<code>00100000000000000000000000000000</code></p>\n<p>不接受新的task，处理队列中的task，终止正在处理的task</p>\n</li>\n<li><p><strong>TIDYNG</strong>：<code>01000000000000000000000000000000</code></p>\n<p>所有的task结束，workerCount为0，无活跃线程</p>\n</li>\n<li><p><strong>TERMINATED</strong>：<code>011000000000000000000000000000000</code></p>\n<p>terminated()方法执行结束</p>\n</li>\n</ul>\n<p>同时在线程池中还定义了三个方法来对ctl变量进行操作，其中两个是从ctl中获取workerCount和runStart，一个是通过指定的workerCount和runStat生成ctl：</p>\n<p>​    <img src=\"03.png\" alt></p>\n<p><code>runStateOf</code>和<code>workerCountOf</code>都是简单的通过<code>&amp;</code>计算将低29为或者高3位置0。而<code>ctlOf</code>这是通过 <code>|</code>操作将高3位和低29位组合到一起。</p>\n<p>ctl变量的初始化语句入如下，表示的是running状态，当前worker数为0：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AtomicInteger ctl = <span class=\"keyword\">new</span> AtomicInteger(ctlOf(RUNNING, <span class=\"number\">0</span>));</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-2-2-提交任务流程\"><a href=\"#1-2-2-提交任务流程\" class=\"headerlink\" title=\"1.2.2 提交任务流程\"></a>1.2.2 提交任务流程</h3><p>通过ThreadPoolExecutor提交任务有两种方式，一种是execute，由他自己实现。另一种是submit，由其父类AbstractExecutorService实现。</p>\n<p>这里需要提前说明一些ThreadPoolExecutor类的一些属性：</p>\n<ul>\n<li><p>workers：HashSet 用来存放线程池worker资源(线程)</p>\n</li>\n<li><p>workQueue：BlockingQueue 用来存放用户提交的task(Runnable)</p>\n</li>\n</ul>\n<h4 id=\"1-2-2-1-通过execute提交task\"><a href=\"#1-2-2-1-通过execute提交task\" class=\"headerlink\" title=\"1.2.2.1 通过execute提交task\"></a>1.2.2.1 通过execute提交task</h4><p><strong>execute(Runnable command)方法</strong></p>\n<p>这个方法体比较简短，我就直接全部粘过来了。</p>\n<p><img src=\"04.png\" alt></p>\n<p>通过代码我们可以看到，最外围的分支结构有三个：</p>\n<ol>\n<li>如果线程池的worker数量小于<code>corePoolSize</code>,就会添加一个worker，执行当前的task(这里我们先不探究addWorker执行了什么操作)；</li>\n<li>如果第一种情况没有满足(当前wroker数已经达到了corePoolSize大小或者addWorker失败)，就把task添加到阻塞队列中。这个过程成功之后，就会进行一次double-check。</li>\n<li>如果当前worker数量大于coreSize，且队列已满，就会尝试创建一个非核心线程来执行当前task。创建失败的话就会直接使用饱和策略处理task。</li>\n</ol>\n<blockquote>\n<p>在double-check的过程中如果发现线程池已经不在运行状态就会把当前task移除，并使用饱和策略处理它。否则就会检查是否有必要创建一些新的线程。</p>\n</blockquote>\n<p><img src=\"05.png\" alt=\"图片使用Visio绘制\"></p>\n<p><strong>addWorker(Runnable firstTask, boolean core)方法</strong></p>\n<p>这里的代码分解一下，首先看一下方法的参数列表：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addWorker</span><span class=\"params\">(Runnable firstTask, <span class=\"keyword\">boolean</span> core)</span></span></span><br></pre></td></tr></table></figure>\n<p>这个方法需要传递两个参数，firstTask表示添加的新worker处理的第一个任务，布尔型的core表示添加的是否为核心线程。</p>\n<p>跳过线程状态校验的过程，我们直接看这一段：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> wc = workerCountOf(c);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (wc &gt;= CAPACITY ||</span><br><span class=\"line\">        wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class=\"line\">        <span class=\"keyword\">break</span> retry;</span><br><span class=\"line\">    c = ctl.get();  <span class=\"comment\">// Re-read ctl</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (runStateOf(c) != rs)</span><br><span class=\"line\">        <span class=\"keyword\">continue</span> retry;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里是循环CAS来增加ctl的数值，一旦增加成功，就会正式地创建线程。</p>\n<p>线面是创建线程的流程：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">boolean</span> workerStarted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"><span class=\"keyword\">boolean</span> workerAdded = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">Worker w = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    w = <span class=\"keyword\">new</span> Worker(firstTask);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Thread t = w.thread;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (t != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> ReentrantLock mainLock = <span class=\"keyword\">this</span>.mainLock;</span><br><span class=\"line\">        mainLock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> rs = runStateOf(ctl.get());</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (rs &lt; SHUTDOWN ||</span><br><span class=\"line\">                (rs == SHUTDOWN &amp;&amp; firstTask == <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (t.isAlive()) </span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalThreadStateException();</span><br><span class=\"line\">                workers.add(w);</span><br><span class=\"line\">                <span class=\"keyword\">int</span> s = workers.size();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (s &gt; largestPoolSize)</span><br><span class=\"line\">                    largestPoolSize = s;</span><br><span class=\"line\">                workerAdded = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            mainLock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (workerAdded) &#123;</span><br><span class=\"line\">            t.start();</span><br><span class=\"line\">            workerStarted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (! workerStarted)</span><br><span class=\"line\">        addWorkerFailed(w);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> workerStarted;</span><br></pre></td></tr></table></figure>\n<p> 这里是直接创建了一个worker对象，而Worker的构造方法如下：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Worker(Runnable firstTask) &#123;</span><br><span class=\"line\">    setState(-<span class=\"number\">1</span>); </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.firstTask = firstTask;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.thread = getThreadFactory().newThread(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，在构造方法中，Worker创建了一个新的线程作为成员变量。</p>\n<p>当一个worker创建之后，还会进行重复校验，已确定worker确实创建成功。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (rs &lt; SHUTDOWN ||(rs == SHUTDOWN &amp;&amp; firstTask == <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (t.isAlive()) </span><br><span class=\"line\">\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalThreadStateException();</span><br><span class=\"line\">    workers.add(w);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> s = workers.size();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s &gt; largestPoolSize)</span><br><span class=\"line\">    largestPoolSize = s;</span><br><span class=\"line\">    workerAdded = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>线程创建成功之后，就会启动worker。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">if</span> (workerAdded) &#123;</span><br><span class=\"line\">\tt.start();</span><br><span class=\"line\">\tworkerStarted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>Worker</strong></p>\n<p>那么线程池创建了worker线程之后都干些什么呢？如果队列中没有任务要做，线程如何保活呢？如果队列中有worker，线程又会如何去执行呢？为了了解这些，剖析一下Worker的代码就很有必要了。  </p>\n<p>ThreadPoolExecutor类通过一个HashSet&lt;Worker>来存放Worker对象：</p>\n<p> <code>private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;();</code></p>\n<p>通过Worker的构造器我们看到Worker在构造线程的时候是将自身作为参数传到方法中的，因为其本身也实现了Runnable接口，所以当执行t.start()的时候，实际上执行的是Worker的run()方法。一下是wroker的runWorker方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">runWorker</span><span class=\"params\">(Worker w)</span> </span>&#123;</span><br><span class=\"line\">    Thread wt = Thread.currentThread();</span><br><span class=\"line\">    Runnable task = w.firstTask;</span><br><span class=\"line\">    w.firstTask = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    w.unlock();</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> completedAbruptly = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (task != <span class=\"keyword\">null</span> || (task = getTask()) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            w.lock();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class=\"line\">                 (Thread.interrupted() &amp;&amp;</span><br><span class=\"line\">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class=\"line\">                !wt.isInterrupted())</span><br><span class=\"line\">                wt.interrupt();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                beforeExecute(wt, task);</span><br><span class=\"line\">                Throwable thrown = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    task.run();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (RuntimeException x) &#123;</span><br><span class=\"line\">                    thrown = x; <span class=\"keyword\">throw</span> x;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Error x) &#123;</span><br><span class=\"line\">                    thrown = x; <span class=\"keyword\">throw</span> x;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Throwable x) &#123;</span><br><span class=\"line\">                    thrown = x; <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(x);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    afterExecute(task, thrown);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                task = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                w.completedTasks++;</span><br><span class=\"line\">                w.unlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        completedAbruptly = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        processWorkerExit(w, completedAbruptly);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>粗略地看一下代码，我们知道worker首先会判断自己是否有属于自己的firstTask，如果有的话，就先执行这个task，这里是task.run()，只是普通的方法调用，执行了task的逻辑。当自己的第一个task执行完之后，worker就会进行循环，通过getTask()方法不停地从workerQueue中获取task。这个getTask是个阻塞方法，会一直循环直到返回task或者线程池状态不为running的时刻。</p>\n<p>当然，这个getTask()的工作内容不仅仅是返回队列中的task，同时也管理着非核心线程的存活。我们通过参数指定了非核心线程的存活时间，当线程池中有非核心线程且线程空闲的时间超过了指定的时间，就会做掉这些线程。这里它是通过<code>workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS)</code>这个方式实现，当超过这个等待时间获取到的结果依然为null，表示当前的线程已经空闲了keepAliveTime这么长时间了，属于超时的非核心线程。之后会return null，在worker的runWorker()方法中调用processWorkerExit()方法结束当前worker。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class=\"line\">    &amp;&amp; (wc &gt; <span class=\"number\">1</span> || workQueue.isEmpty())) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    Runnable r = timed ?</span><br><span class=\"line\">        workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class=\"line\">        workQueue.take();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (r != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">    timedOut = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (InterruptedException retry) &#123;</span><br><span class=\"line\">    timedOut = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"1-2-2-2-通过submit提交task\"><a href=\"#1-2-2-2-通过submit提交task\" class=\"headerlink\" title=\"1.2.2.2 通过submit提交task\"></a>1.2.2.2 通过submit提交task</h4><p>这个方法是在ThreadPoolExecutor的父类AbstractExecutorService中定义的。AbstractExecutorService是一个抽象类。而submit的逻辑也比较简单：  </p>\n<p><img src=\"06.png\" alt></p>\n<p>参数的主要区别在于Runnable和Callable，前者无返回值后者有返回值，可以通过Future的get方法阻塞获取。</p>\n<p>通过submit提交的task可以获取一个future对象，可以对已提交的task进行相关操作。例如获取返回值或者判断运行状态等等。</p>\n<p>可以看到，submit只是将task封装成了一个ftask，然后调用了execute方法调教了这个task到线程池中。这里使用了<strong>模板方法</strong>模式，submit调用的是由子类的线程池实现的execute，也就是上面的execute方法。</p>\n<h1 id=\"小结：\"><a href=\"#小结：\" class=\"headerlink\" title=\"小结：\"></a>小结：</h1><p>关于线程池的构造参数含义和参数的使用逻辑在日常使用过程中还是很值得关注的，对于日后线程池问题定位调优都会有不少的帮助。理解线程池工作原理，线程池中worker的执行流程可以让我们对池化技术和资源利用的看法有更进一步的了解。</p>"},{"title":"【翻译】01-Zookeeper简介","date":"2020-04-08T01:42:55.000Z","_content":"\nZookeeper 是一款使用关于分布式应用的高性能协调服务。它可以通过一些简单的接口实现通用服务的可见性。例如命名，配置管理，同步以及组服务等等，使用zookeeper可以避免我们为这些功能进行耗时耗力的开发。开发人员可以直接使用现有的接口实现一致性，组管理，leader选举以及相关的业务协议。\n\n<!-- more -->\n\n# Zookeeper简介\n\n\n\n## 1. Zookeeper：为分布式应用而生的分布式协调服务\n\nZookeeper 是一个适用于分布式应用的分布式协调服务组件。它为用户定义了一些基本的操作，用户可以基于这些操作实现自身应用的同步，配置维护，组管理和命名等需求。Zookeeper的设计的特点是使用类似文件系统的树结构，以及其易于理解和实现的编程。\n\n众所周知，协调服务很难确保其准确性。并且，处理不当的协调服务很容易引起竞争条件和死锁。而Zookeeper服务则让我们的应用不必耗费精力从头开始去实现这些协调和同步功能。\n\n## 2. 设计目标\n\n1. **简单：**用户可以通过Zookeeper实现服务之间的协调服务，这归功于Zookeeper简单易懂的数据结构。Zookeeper使用了分层的命名空间，跟传统的文件系统类似。这些分层的命名空间维护着已注册的数据**ZNode**，类似传统文件系统中的文件或者文件夹，区别在于前者可以存储数据。因为Zookeeper的数据都是存储在内存中的，所以他可以在低实验的情况下实现较高的吞吐量。\n\n   Zookeeper的实现非常重视**高性能**，**高可用**和**严格有序的访问**。高性能意味着Zookeeper适用于大型的分布式系统。高可用可以让Zookeeper有效的避免单点故障的问题。而严格有序可以让一些复杂的同步原语通过客户端就能实现。 \n\n   \n\n2. **多副本：**如同Zookeeper负责协调的组件类似，Zookeeper本身也实现了多副本机制。\n\n   ![zkservice](zkservice.jpg)\n\n   组成Zookeeper集群的服务器必须能够相互感知。他们共同维护了一个内存状态镜像以及存储在持久存储介质上的事务日志和snapshot。只要集群中的大部分节点是OK的，那么Zookeeper服务就是可用的。\n\n   Zookeeper的客户端可以连接到集群中的任意一台服务器上。客户端需要维护自身的TCP连接，它会通过这个连接请求，获取服务端响应，获取watch时间，同时它也会通过这个连接来发送心跳信息。如果连接到服务端的TCP连接断掉了，客户端就会尝试连接到其他的服务端。\n\n   \n\n3. **有序：**对于每一个更新操作，Zookeeper都会通过一个数字标记。这个数字反映了这个操作在所有事物操作中的顺序。后续的操作就能通过这个序号来实现更高级别的抽象，例如同步原语。\n\n4. **响应快速：**Zookeeper很快，尤其是\"读操作\"，贼快！使用Zookeeper的应用运行在成千上万台服务器上，而Zookeeper在多读少写的场景中表现尤佳，一般情况下，读写比例大约在10:1会比较好。\n\n## 3. 数据模型 & 分层命名空间\n\nZookeeper使用的命名空间和传统的文件系统很类似。名称是由路径组合而来。Zookeeper中每个node的命名空间都是一个路径。\n\n![zknamespace](zknamespace.jpg)\n\n## 4. 节点 & 临时节点 \n\nZookeeper和普通的文件系统不同的是他的节点可以关联数据，同时它还可以有子节点。如果站在普通文件系统的角度看，这就像是一个文件夹有数据内容。（Zookeeper这样设计的目的是为了存放协调数据：状态信息，配置，位置信息等等。所以在单个znode上存放的数据通常都比较小，一般在byte到kb之间。）Zookeeper中的数据节点一般称之为ZNode。\n\n  ZNode维护了一个**状态数据结构**，包含了版本号，表示数据更改，ACL更改，还有一个时间戳用于缓存确认和用于协调更新。每当一个ZNode数据改变时，其对应的版本号就会增加。Zookeeper客户端在获取ZNode数据的同时也会获取到它的版本号。\n\n存储在每个Znode上的数据都能都实现原子级别的读写。多操作获取节点对应的数据，写操作则会覆盖原来的数据。每个Znode都有一个Access Control List (ACL)来约束哪些用户有权限执行相关的操作。\n\nZookeeper 中也有**临时节点**的概念。这种类型的节点会在客户端连接断开的时候删除，反之，只要客户端连接并没有执行删除操作的情况下，它就会一直存在。\n\n## 5. 条件更新 & watches\n\nZookeeper支持Watch。客户端可以在ZNode上创建watch, watch 会跟ZNode删除及更改关联。 当一个watch被创建， 客户端就可以在ZNode更改的时候收到一些包表明Znode已经发生了更改。如果客户端和服务端的连接断开了，那么客户端会收到一个本地提示。  \n\n## 6. 提供的保证\n\nZookeeper很快也很简单。因为它的目标是作为构建更复杂的服务(比如同步)的基础，所以它提供了如下的保证：\n\n* **顺序一致性**：来自客户端的事务操作会按照提交的顺序一一执行；\n* **原子性**：更新操作要么成功要么失败，不会有中间结果；\n* **单一视图**：无论客户端连接的是哪个服务器，它看到的服务端数据模型都是一致的；\n* **可靠性**：一旦某个事务被执行了，那么执行结果就会一直保留，直到另一个客户端覆写了这个事务操作；\n* **实时性**：一旦事务操作被执行，那么Zookeeper可以保证在 **一段时间**  内这个操作会被所有的客户端感知到。即他能够保证最终一致性。\n\n## 7. 简单的API\n\nZookeeper的设计目标之一就是提供简单的编程接口。所以，Zookeeper只支持以下的操作：  \n\n* **create**：在指定路径下创建ZNode；\n* **delete**：删除一个ZNode；\n* **exists**：判断指定的ZNode是否存在；\n* **get data**：读取ZNode的数据；\n* **set data**：设置ZNode的数据；\n* **get children**：获取指定ZNode的子目录列表；\n* **sync**：等待数据同步\n\n## 8. 实现 \n\n下图展示了Zookeeper的高级组件。除了Request Processor之外，每个服务器都会有其他组件的副本。  \n\n![zkcomponents](zkcomponents.jpg)\n\nReplicated Database(副本数据库)是一个内存数据库，它维护了整个集群的data tree。更新操作会被记录到磁盘上，这样它就可以被恢复了。同时，写操作被内存数据库执行之前也是先序列化到本地的。 \n\n每个Zookeeper服务端都可以为 客户端提供服务，客户端可以连接任意一个服务端来提交请求。对于 **读** 请求，服务端会从本地的内存数据库副本中获取数据返回，而对于 **写** 请求以及更改服务状态的请求则会由一致性协议来处理。  \n\n其一致性要求所有的来自客户端的 **写** 请求都要被转发到**Leader**节点上。除了Leader节点，剩下的节点称为 **Follower** 节点。它们会接受Leader节点的proposal，并且确定消息传递。消息层负责在出现故障时替换Leader，并将Follower与Leader同步。  \n\nZookeeper使用自定义的原子性消息协议。因为消息层是原子性的，所以zookeeper可以保证本地的副本不会出现偏差。当Leader节点接收到一个写请求，它会计算执行这个写请求时系统的状态，然后将其转换成包含这一状态的事务。  \n\n\n\n","source":"_posts/【翻译】Zookeeper01-Zookeeper简介.md","raw":"---\ntitle: 【翻译】01-Zookeeper简介\ndate: 2020-04-08 09:42:55\ntags:\n - zookeeper\n - 大数据\ncategories: \n - 大数据组件\n - zookeeper\n\n---\n\nZookeeper 是一款使用关于分布式应用的高性能协调服务。它可以通过一些简单的接口实现通用服务的可见性。例如命名，配置管理，同步以及组服务等等，使用zookeeper可以避免我们为这些功能进行耗时耗力的开发。开发人员可以直接使用现有的接口实现一致性，组管理，leader选举以及相关的业务协议。\n\n<!-- more -->\n\n# Zookeeper简介\n\n\n\n## 1. Zookeeper：为分布式应用而生的分布式协调服务\n\nZookeeper 是一个适用于分布式应用的分布式协调服务组件。它为用户定义了一些基本的操作，用户可以基于这些操作实现自身应用的同步，配置维护，组管理和命名等需求。Zookeeper的设计的特点是使用类似文件系统的树结构，以及其易于理解和实现的编程。\n\n众所周知，协调服务很难确保其准确性。并且，处理不当的协调服务很容易引起竞争条件和死锁。而Zookeeper服务则让我们的应用不必耗费精力从头开始去实现这些协调和同步功能。\n\n## 2. 设计目标\n\n1. **简单：**用户可以通过Zookeeper实现服务之间的协调服务，这归功于Zookeeper简单易懂的数据结构。Zookeeper使用了分层的命名空间，跟传统的文件系统类似。这些分层的命名空间维护着已注册的数据**ZNode**，类似传统文件系统中的文件或者文件夹，区别在于前者可以存储数据。因为Zookeeper的数据都是存储在内存中的，所以他可以在低实验的情况下实现较高的吞吐量。\n\n   Zookeeper的实现非常重视**高性能**，**高可用**和**严格有序的访问**。高性能意味着Zookeeper适用于大型的分布式系统。高可用可以让Zookeeper有效的避免单点故障的问题。而严格有序可以让一些复杂的同步原语通过客户端就能实现。 \n\n   \n\n2. **多副本：**如同Zookeeper负责协调的组件类似，Zookeeper本身也实现了多副本机制。\n\n   ![zkservice](zkservice.jpg)\n\n   组成Zookeeper集群的服务器必须能够相互感知。他们共同维护了一个内存状态镜像以及存储在持久存储介质上的事务日志和snapshot。只要集群中的大部分节点是OK的，那么Zookeeper服务就是可用的。\n\n   Zookeeper的客户端可以连接到集群中的任意一台服务器上。客户端需要维护自身的TCP连接，它会通过这个连接请求，获取服务端响应，获取watch时间，同时它也会通过这个连接来发送心跳信息。如果连接到服务端的TCP连接断掉了，客户端就会尝试连接到其他的服务端。\n\n   \n\n3. **有序：**对于每一个更新操作，Zookeeper都会通过一个数字标记。这个数字反映了这个操作在所有事物操作中的顺序。后续的操作就能通过这个序号来实现更高级别的抽象，例如同步原语。\n\n4. **响应快速：**Zookeeper很快，尤其是\"读操作\"，贼快！使用Zookeeper的应用运行在成千上万台服务器上，而Zookeeper在多读少写的场景中表现尤佳，一般情况下，读写比例大约在10:1会比较好。\n\n## 3. 数据模型 & 分层命名空间\n\nZookeeper使用的命名空间和传统的文件系统很类似。名称是由路径组合而来。Zookeeper中每个node的命名空间都是一个路径。\n\n![zknamespace](zknamespace.jpg)\n\n## 4. 节点 & 临时节点 \n\nZookeeper和普通的文件系统不同的是他的节点可以关联数据，同时它还可以有子节点。如果站在普通文件系统的角度看，这就像是一个文件夹有数据内容。（Zookeeper这样设计的目的是为了存放协调数据：状态信息，配置，位置信息等等。所以在单个znode上存放的数据通常都比较小，一般在byte到kb之间。）Zookeeper中的数据节点一般称之为ZNode。\n\n  ZNode维护了一个**状态数据结构**，包含了版本号，表示数据更改，ACL更改，还有一个时间戳用于缓存确认和用于协调更新。每当一个ZNode数据改变时，其对应的版本号就会增加。Zookeeper客户端在获取ZNode数据的同时也会获取到它的版本号。\n\n存储在每个Znode上的数据都能都实现原子级别的读写。多操作获取节点对应的数据，写操作则会覆盖原来的数据。每个Znode都有一个Access Control List (ACL)来约束哪些用户有权限执行相关的操作。\n\nZookeeper 中也有**临时节点**的概念。这种类型的节点会在客户端连接断开的时候删除，反之，只要客户端连接并没有执行删除操作的情况下，它就会一直存在。\n\n## 5. 条件更新 & watches\n\nZookeeper支持Watch。客户端可以在ZNode上创建watch, watch 会跟ZNode删除及更改关联。 当一个watch被创建， 客户端就可以在ZNode更改的时候收到一些包表明Znode已经发生了更改。如果客户端和服务端的连接断开了，那么客户端会收到一个本地提示。  \n\n## 6. 提供的保证\n\nZookeeper很快也很简单。因为它的目标是作为构建更复杂的服务(比如同步)的基础，所以它提供了如下的保证：\n\n* **顺序一致性**：来自客户端的事务操作会按照提交的顺序一一执行；\n* **原子性**：更新操作要么成功要么失败，不会有中间结果；\n* **单一视图**：无论客户端连接的是哪个服务器，它看到的服务端数据模型都是一致的；\n* **可靠性**：一旦某个事务被执行了，那么执行结果就会一直保留，直到另一个客户端覆写了这个事务操作；\n* **实时性**：一旦事务操作被执行，那么Zookeeper可以保证在 **一段时间**  内这个操作会被所有的客户端感知到。即他能够保证最终一致性。\n\n## 7. 简单的API\n\nZookeeper的设计目标之一就是提供简单的编程接口。所以，Zookeeper只支持以下的操作：  \n\n* **create**：在指定路径下创建ZNode；\n* **delete**：删除一个ZNode；\n* **exists**：判断指定的ZNode是否存在；\n* **get data**：读取ZNode的数据；\n* **set data**：设置ZNode的数据；\n* **get children**：获取指定ZNode的子目录列表；\n* **sync**：等待数据同步\n\n## 8. 实现 \n\n下图展示了Zookeeper的高级组件。除了Request Processor之外，每个服务器都会有其他组件的副本。  \n\n![zkcomponents](zkcomponents.jpg)\n\nReplicated Database(副本数据库)是一个内存数据库，它维护了整个集群的data tree。更新操作会被记录到磁盘上，这样它就可以被恢复了。同时，写操作被内存数据库执行之前也是先序列化到本地的。 \n\n每个Zookeeper服务端都可以为 客户端提供服务，客户端可以连接任意一个服务端来提交请求。对于 **读** 请求，服务端会从本地的内存数据库副本中获取数据返回，而对于 **写** 请求以及更改服务状态的请求则会由一致性协议来处理。  \n\n其一致性要求所有的来自客户端的 **写** 请求都要被转发到**Leader**节点上。除了Leader节点，剩下的节点称为 **Follower** 节点。它们会接受Leader节点的proposal，并且确定消息传递。消息层负责在出现故障时替换Leader，并将Follower与Leader同步。  \n\nZookeeper使用自定义的原子性消息协议。因为消息层是原子性的，所以zookeeper可以保证本地的副本不会出现偏差。当Leader节点接收到一个写请求，它会计算执行这个写请求时系统的状态，然后将其转换成包含这一状态的事务。  \n\n\n\n","slug":"【翻译】Zookeeper01-Zookeeper简介","published":1,"updated":"2020-04-08T12:19:29.823Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8tjbxty00066gonx5jmues6","content":"<p>Zookeeper 是一款使用关于分布式应用的高性能协调服务。它可以通过一些简单的接口实现通用服务的可见性。例如命名，配置管理，同步以及组服务等等，使用zookeeper可以避免我们为这些功能进行耗时耗力的开发。开发人员可以直接使用现有的接口实现一致性，组管理，leader选举以及相关的业务协议。</p>\n<a id=\"more\"></a>\n<h1 id=\"Zookeeper简介\"><a href=\"#Zookeeper简介\" class=\"headerlink\" title=\"Zookeeper简介\"></a>Zookeeper简介</h1><h2 id=\"1-Zookeeper：为分布式应用而生的分布式协调服务\"><a href=\"#1-Zookeeper：为分布式应用而生的分布式协调服务\" class=\"headerlink\" title=\"1. Zookeeper：为分布式应用而生的分布式协调服务\"></a>1. Zookeeper：为分布式应用而生的分布式协调服务</h2><p>Zookeeper 是一个适用于分布式应用的分布式协调服务组件。它为用户定义了一些基本的操作，用户可以基于这些操作实现自身应用的同步，配置维护，组管理和命名等需求。Zookeeper的设计的特点是使用类似文件系统的树结构，以及其易于理解和实现的编程。</p>\n<p>众所周知，协调服务很难确保其准确性。并且，处理不当的协调服务很容易引起竞争条件和死锁。而Zookeeper服务则让我们的应用不必耗费精力从头开始去实现这些协调和同步功能。</p>\n<h2 id=\"2-设计目标\"><a href=\"#2-设计目标\" class=\"headerlink\" title=\"2. 设计目标\"></a>2. 设计目标</h2><ol>\n<li><p><strong>简单：</strong>用户可以通过Zookeeper实现服务之间的协调服务，这归功于Zookeeper简单易懂的数据结构。Zookeeper使用了分层的命名空间，跟传统的文件系统类似。这些分层的命名空间维护着已注册的数据<strong>ZNode</strong>，类似传统文件系统中的文件或者文件夹，区别在于前者可以存储数据。因为Zookeeper的数据都是存储在内存中的，所以他可以在低实验的情况下实现较高的吞吐量。</p>\n<p>Zookeeper的实现非常重视<strong>高性能</strong>，<strong>高可用</strong>和<strong>严格有序的访问</strong>。高性能意味着Zookeeper适用于大型的分布式系统。高可用可以让Zookeeper有效的避免单点故障的问题。而严格有序可以让一些复杂的同步原语通过客户端就能实现。 </p>\n</li>\n</ol>\n<ol start=\"2\">\n<li><p><strong>多副本：</strong>如同Zookeeper负责协调的组件类似，Zookeeper本身也实现了多副本机制。</p>\n<p><img src=\"zkservice.jpg\" alt=\"zkservice\"></p>\n<p>组成Zookeeper集群的服务器必须能够相互感知。他们共同维护了一个内存状态镜像以及存储在持久存储介质上的事务日志和snapshot。只要集群中的大部分节点是OK的，那么Zookeeper服务就是可用的。</p>\n<p>Zookeeper的客户端可以连接到集群中的任意一台服务器上。客户端需要维护自身的TCP连接，它会通过这个连接请求，获取服务端响应，获取watch时间，同时它也会通过这个连接来发送心跳信息。如果连接到服务端的TCP连接断掉了，客户端就会尝试连接到其他的服务端。</p>\n</li>\n</ol>\n<ol start=\"3\">\n<li><p><strong>有序：</strong>对于每一个更新操作，Zookeeper都会通过一个数字标记。这个数字反映了这个操作在所有事物操作中的顺序。后续的操作就能通过这个序号来实现更高级别的抽象，例如同步原语。</p>\n</li>\n<li><p><strong>响应快速：</strong>Zookeeper很快，尤其是”读操作”，贼快！使用Zookeeper的应用运行在成千上万台服务器上，而Zookeeper在多读少写的场景中表现尤佳，一般情况下，读写比例大约在10:1会比较好。</p>\n</li>\n</ol>\n<h2 id=\"3-数据模型-amp-分层命名空间\"><a href=\"#3-数据模型-amp-分层命名空间\" class=\"headerlink\" title=\"3. 数据模型 &amp; 分层命名空间\"></a>3. 数据模型 &amp; 分层命名空间</h2><p>Zookeeper使用的命名空间和传统的文件系统很类似。名称是由路径组合而来。Zookeeper中每个node的命名空间都是一个路径。</p>\n<p><img src=\"zknamespace.jpg\" alt=\"zknamespace\"></p>\n<h2 id=\"4-节点-amp-临时节点\"><a href=\"#4-节点-amp-临时节点\" class=\"headerlink\" title=\"4. 节点 &amp; 临时节点\"></a>4. 节点 &amp; 临时节点</h2><p>Zookeeper和普通的文件系统不同的是他的节点可以关联数据，同时它还可以有子节点。如果站在普通文件系统的角度看，这就像是一个文件夹有数据内容。（Zookeeper这样设计的目的是为了存放协调数据：状态信息，配置，位置信息等等。所以在单个znode上存放的数据通常都比较小，一般在byte到kb之间。）Zookeeper中的数据节点一般称之为ZNode。</p>\n<p>  ZNode维护了一个<strong>状态数据结构</strong>，包含了版本号，表示数据更改，ACL更改，还有一个时间戳用于缓存确认和用于协调更新。每当一个ZNode数据改变时，其对应的版本号就会增加。Zookeeper客户端在获取ZNode数据的同时也会获取到它的版本号。</p>\n<p>存储在每个Znode上的数据都能都实现原子级别的读写。多操作获取节点对应的数据，写操作则会覆盖原来的数据。每个Znode都有一个Access Control List (ACL)来约束哪些用户有权限执行相关的操作。</p>\n<p>Zookeeper 中也有<strong>临时节点</strong>的概念。这种类型的节点会在客户端连接断开的时候删除，反之，只要客户端连接并没有执行删除操作的情况下，它就会一直存在。</p>\n<h2 id=\"5-条件更新-amp-watches\"><a href=\"#5-条件更新-amp-watches\" class=\"headerlink\" title=\"5. 条件更新 &amp; watches\"></a>5. 条件更新 &amp; watches</h2><p>Zookeeper支持Watch。客户端可以在ZNode上创建watch, watch 会跟ZNode删除及更改关联。 当一个watch被创建， 客户端就可以在ZNode更改的时候收到一些包表明Znode已经发生了更改。如果客户端和服务端的连接断开了，那么客户端会收到一个本地提示。  </p>\n<h2 id=\"6-提供的保证\"><a href=\"#6-提供的保证\" class=\"headerlink\" title=\"6. 提供的保证\"></a>6. 提供的保证</h2><p>Zookeeper很快也很简单。因为它的目标是作为构建更复杂的服务(比如同步)的基础，所以它提供了如下的保证：</p>\n<ul>\n<li><strong>顺序一致性</strong>：来自客户端的事务操作会按照提交的顺序一一执行；</li>\n<li><strong>原子性</strong>：更新操作要么成功要么失败，不会有中间结果；</li>\n<li><strong>单一视图</strong>：无论客户端连接的是哪个服务器，它看到的服务端数据模型都是一致的；</li>\n<li><strong>可靠性</strong>：一旦某个事务被执行了，那么执行结果就会一直保留，直到另一个客户端覆写了这个事务操作；</li>\n<li><strong>实时性</strong>：一旦事务操作被执行，那么Zookeeper可以保证在 <strong>一段时间</strong>  内这个操作会被所有的客户端感知到。即他能够保证最终一致性。</li>\n</ul>\n<h2 id=\"7-简单的API\"><a href=\"#7-简单的API\" class=\"headerlink\" title=\"7. 简单的API\"></a>7. 简单的API</h2><p>Zookeeper的设计目标之一就是提供简单的编程接口。所以，Zookeeper只支持以下的操作：  </p>\n<ul>\n<li><strong>create</strong>：在指定路径下创建ZNode；</li>\n<li><strong>delete</strong>：删除一个ZNode；</li>\n<li><strong>exists</strong>：判断指定的ZNode是否存在；</li>\n<li><strong>get data</strong>：读取ZNode的数据；</li>\n<li><strong>set data</strong>：设置ZNode的数据；</li>\n<li><strong>get children</strong>：获取指定ZNode的子目录列表；</li>\n<li><strong>sync</strong>：等待数据同步</li>\n</ul>\n<h2 id=\"8-实现\"><a href=\"#8-实现\" class=\"headerlink\" title=\"8. 实现\"></a>8. 实现</h2><p>下图展示了Zookeeper的高级组件。除了Request Processor之外，每个服务器都会有其他组件的副本。  </p>\n<p><img src=\"zkcomponents.jpg\" alt=\"zkcomponents\"></p>\n<p>Replicated Database(副本数据库)是一个内存数据库，它维护了整个集群的data tree。更新操作会被记录到磁盘上，这样它就可以被恢复了。同时，写操作被内存数据库执行之前也是先序列化到本地的。 </p>\n<p>每个Zookeeper服务端都可以为 客户端提供服务，客户端可以连接任意一个服务端来提交请求。对于 <strong>读</strong> 请求，服务端会从本地的内存数据库副本中获取数据返回，而对于 <strong>写</strong> 请求以及更改服务状态的请求则会由一致性协议来处理。  </p>\n<p>其一致性要求所有的来自客户端的 <strong>写</strong> 请求都要被转发到<strong>Leader</strong>节点上。除了Leader节点，剩下的节点称为 <strong>Follower</strong> 节点。它们会接受Leader节点的proposal，并且确定消息传递。消息层负责在出现故障时替换Leader，并将Follower与Leader同步。  </p>\n<p>Zookeeper使用自定义的原子性消息协议。因为消息层是原子性的，所以zookeeper可以保证本地的副本不会出现偏差。当Leader节点接收到一个写请求，它会计算执行这个写请求时系统的状态，然后将其转换成包含这一状态的事务。  </p>\n","site":{"data":{}},"excerpt":"<p>Zookeeper 是一款使用关于分布式应用的高性能协调服务。它可以通过一些简单的接口实现通用服务的可见性。例如命名，配置管理，同步以及组服务等等，使用zookeeper可以避免我们为这些功能进行耗时耗力的开发。开发人员可以直接使用现有的接口实现一致性，组管理，leader选举以及相关的业务协议。</p>","more":"<h1 id=\"Zookeeper简介\"><a href=\"#Zookeeper简介\" class=\"headerlink\" title=\"Zookeeper简介\"></a>Zookeeper简介</h1><h2 id=\"1-Zookeeper：为分布式应用而生的分布式协调服务\"><a href=\"#1-Zookeeper：为分布式应用而生的分布式协调服务\" class=\"headerlink\" title=\"1. Zookeeper：为分布式应用而生的分布式协调服务\"></a>1. Zookeeper：为分布式应用而生的分布式协调服务</h2><p>Zookeeper 是一个适用于分布式应用的分布式协调服务组件。它为用户定义了一些基本的操作，用户可以基于这些操作实现自身应用的同步，配置维护，组管理和命名等需求。Zookeeper的设计的特点是使用类似文件系统的树结构，以及其易于理解和实现的编程。</p>\n<p>众所周知，协调服务很难确保其准确性。并且，处理不当的协调服务很容易引起竞争条件和死锁。而Zookeeper服务则让我们的应用不必耗费精力从头开始去实现这些协调和同步功能。</p>\n<h2 id=\"2-设计目标\"><a href=\"#2-设计目标\" class=\"headerlink\" title=\"2. 设计目标\"></a>2. 设计目标</h2><ol>\n<li><p><strong>简单：</strong>用户可以通过Zookeeper实现服务之间的协调服务，这归功于Zookeeper简单易懂的数据结构。Zookeeper使用了分层的命名空间，跟传统的文件系统类似。这些分层的命名空间维护着已注册的数据<strong>ZNode</strong>，类似传统文件系统中的文件或者文件夹，区别在于前者可以存储数据。因为Zookeeper的数据都是存储在内存中的，所以他可以在低实验的情况下实现较高的吞吐量。</p>\n<p>Zookeeper的实现非常重视<strong>高性能</strong>，<strong>高可用</strong>和<strong>严格有序的访问</strong>。高性能意味着Zookeeper适用于大型的分布式系统。高可用可以让Zookeeper有效的避免单点故障的问题。而严格有序可以让一些复杂的同步原语通过客户端就能实现。 </p>\n</li>\n</ol>\n<ol start=\"2\">\n<li><p><strong>多副本：</strong>如同Zookeeper负责协调的组件类似，Zookeeper本身也实现了多副本机制。</p>\n<p><img src=\"zkservice.jpg\" alt=\"zkservice\"></p>\n<p>组成Zookeeper集群的服务器必须能够相互感知。他们共同维护了一个内存状态镜像以及存储在持久存储介质上的事务日志和snapshot。只要集群中的大部分节点是OK的，那么Zookeeper服务就是可用的。</p>\n<p>Zookeeper的客户端可以连接到集群中的任意一台服务器上。客户端需要维护自身的TCP连接，它会通过这个连接请求，获取服务端响应，获取watch时间，同时它也会通过这个连接来发送心跳信息。如果连接到服务端的TCP连接断掉了，客户端就会尝试连接到其他的服务端。</p>\n</li>\n</ol>\n<ol start=\"3\">\n<li><p><strong>有序：</strong>对于每一个更新操作，Zookeeper都会通过一个数字标记。这个数字反映了这个操作在所有事物操作中的顺序。后续的操作就能通过这个序号来实现更高级别的抽象，例如同步原语。</p>\n</li>\n<li><p><strong>响应快速：</strong>Zookeeper很快，尤其是”读操作”，贼快！使用Zookeeper的应用运行在成千上万台服务器上，而Zookeeper在多读少写的场景中表现尤佳，一般情况下，读写比例大约在10:1会比较好。</p>\n</li>\n</ol>\n<h2 id=\"3-数据模型-amp-分层命名空间\"><a href=\"#3-数据模型-amp-分层命名空间\" class=\"headerlink\" title=\"3. 数据模型 &amp; 分层命名空间\"></a>3. 数据模型 &amp; 分层命名空间</h2><p>Zookeeper使用的命名空间和传统的文件系统很类似。名称是由路径组合而来。Zookeeper中每个node的命名空间都是一个路径。</p>\n<p><img src=\"zknamespace.jpg\" alt=\"zknamespace\"></p>\n<h2 id=\"4-节点-amp-临时节点\"><a href=\"#4-节点-amp-临时节点\" class=\"headerlink\" title=\"4. 节点 &amp; 临时节点\"></a>4. 节点 &amp; 临时节点</h2><p>Zookeeper和普通的文件系统不同的是他的节点可以关联数据，同时它还可以有子节点。如果站在普通文件系统的角度看，这就像是一个文件夹有数据内容。（Zookeeper这样设计的目的是为了存放协调数据：状态信息，配置，位置信息等等。所以在单个znode上存放的数据通常都比较小，一般在byte到kb之间。）Zookeeper中的数据节点一般称之为ZNode。</p>\n<p>  ZNode维护了一个<strong>状态数据结构</strong>，包含了版本号，表示数据更改，ACL更改，还有一个时间戳用于缓存确认和用于协调更新。每当一个ZNode数据改变时，其对应的版本号就会增加。Zookeeper客户端在获取ZNode数据的同时也会获取到它的版本号。</p>\n<p>存储在每个Znode上的数据都能都实现原子级别的读写。多操作获取节点对应的数据，写操作则会覆盖原来的数据。每个Znode都有一个Access Control List (ACL)来约束哪些用户有权限执行相关的操作。</p>\n<p>Zookeeper 中也有<strong>临时节点</strong>的概念。这种类型的节点会在客户端连接断开的时候删除，反之，只要客户端连接并没有执行删除操作的情况下，它就会一直存在。</p>\n<h2 id=\"5-条件更新-amp-watches\"><a href=\"#5-条件更新-amp-watches\" class=\"headerlink\" title=\"5. 条件更新 &amp; watches\"></a>5. 条件更新 &amp; watches</h2><p>Zookeeper支持Watch。客户端可以在ZNode上创建watch, watch 会跟ZNode删除及更改关联。 当一个watch被创建， 客户端就可以在ZNode更改的时候收到一些包表明Znode已经发生了更改。如果客户端和服务端的连接断开了，那么客户端会收到一个本地提示。  </p>\n<h2 id=\"6-提供的保证\"><a href=\"#6-提供的保证\" class=\"headerlink\" title=\"6. 提供的保证\"></a>6. 提供的保证</h2><p>Zookeeper很快也很简单。因为它的目标是作为构建更复杂的服务(比如同步)的基础，所以它提供了如下的保证：</p>\n<ul>\n<li><strong>顺序一致性</strong>：来自客户端的事务操作会按照提交的顺序一一执行；</li>\n<li><strong>原子性</strong>：更新操作要么成功要么失败，不会有中间结果；</li>\n<li><strong>单一视图</strong>：无论客户端连接的是哪个服务器，它看到的服务端数据模型都是一致的；</li>\n<li><strong>可靠性</strong>：一旦某个事务被执行了，那么执行结果就会一直保留，直到另一个客户端覆写了这个事务操作；</li>\n<li><strong>实时性</strong>：一旦事务操作被执行，那么Zookeeper可以保证在 <strong>一段时间</strong>  内这个操作会被所有的客户端感知到。即他能够保证最终一致性。</li>\n</ul>\n<h2 id=\"7-简单的API\"><a href=\"#7-简单的API\" class=\"headerlink\" title=\"7. 简单的API\"></a>7. 简单的API</h2><p>Zookeeper的设计目标之一就是提供简单的编程接口。所以，Zookeeper只支持以下的操作：  </p>\n<ul>\n<li><strong>create</strong>：在指定路径下创建ZNode；</li>\n<li><strong>delete</strong>：删除一个ZNode；</li>\n<li><strong>exists</strong>：判断指定的ZNode是否存在；</li>\n<li><strong>get data</strong>：读取ZNode的数据；</li>\n<li><strong>set data</strong>：设置ZNode的数据；</li>\n<li><strong>get children</strong>：获取指定ZNode的子目录列表；</li>\n<li><strong>sync</strong>：等待数据同步</li>\n</ul>\n<h2 id=\"8-实现\"><a href=\"#8-实现\" class=\"headerlink\" title=\"8. 实现\"></a>8. 实现</h2><p>下图展示了Zookeeper的高级组件。除了Request Processor之外，每个服务器都会有其他组件的副本。  </p>\n<p><img src=\"zkcomponents.jpg\" alt=\"zkcomponents\"></p>\n<p>Replicated Database(副本数据库)是一个内存数据库，它维护了整个集群的data tree。更新操作会被记录到磁盘上，这样它就可以被恢复了。同时，写操作被内存数据库执行之前也是先序列化到本地的。 </p>\n<p>每个Zookeeper服务端都可以为 客户端提供服务，客户端可以连接任意一个服务端来提交请求。对于 <strong>读</strong> 请求，服务端会从本地的内存数据库副本中获取数据返回，而对于 <strong>写</strong> 请求以及更改服务状态的请求则会由一致性协议来处理。  </p>\n<p>其一致性要求所有的来自客户端的 <strong>写</strong> 请求都要被转发到<strong>Leader</strong>节点上。除了Leader节点，剩下的节点称为 <strong>Follower</strong> 节点。它们会接受Leader节点的proposal，并且确定消息传递。消息层负责在出现故障时替换Leader，并将Follower与Leader同步。  </p>\n<p>Zookeeper使用自定义的原子性消息协议。因为消息层是原子性的，所以zookeeper可以保证本地的副本不会出现偏差。当Leader节点接收到一个写请求，它会计算执行这个写请求时系统的状态，然后将其转换成包含这一状态的事务。  </p>"},{"title":"组件运维常用命令","date":"2020-03-24T12:19:01.000Z","_content":"\n\n\n组件日常运维命令，云备份。\n\n<!-- more -->\n\n# 服务常用命令【自用】\n\n## Zookeeper\n\n**zk snapshot 格式化**  \n`java -cp ~/software/zookeeper-3.4.6.5/zookeeper-3.4.6.5.jar:/home/zookeeper/software/zookeeper/lib/* org.apache.zookeeper.server.SnapshotFormatter <snapshot文件路径> > ./snapshot.test`\n格式化之后可以通过解析文本获取到znode的相关信息，减少对zk集群访问的压力。\n\n**ZK log日志格式化**\n可以查看服务器的事务操作\n`java -cp .:/home/zookeeper/software/zookeeper/zookeeper-3.4.6.5.jar:/home/zookeeper/software/zookeeper/lib/* org.apache.zookeeper.server.LogFormatter /home/zookeeper/logs/version-2/log.701f247da >> ./logtest`\n\n## Linux\n1. 查看服务端口是否正常 \n   `nc -z -w 1 127.0.0.1 8090 `\n\n2. 查看进程端口\n\n   `netstat -anp |grep <port>`\n\n3. 查看机器CPU和内存资源占用情况\n\n   `top`\n\n4. 查看单个进程的线程占用资源情况\n\n   `top -Hp <pid>`\n\n5. 十进制转十六机制，用来转换线程id，好在stack中搜索\n\n   `printf %x <十进制数>`\n\n\n\n## JVM分析\n**内存分析**\n\n1. 查看内存中对象及其占用的空间\n\n   `jmap -histo pid`\n\n2. 查看进程的堆栈信息，可以通过搜索线程ID查看当前阻塞线程\n\n   `jstack <pid> | vim -`\n\n3. 查看GC情况\n\n   `jstat -gcutil <pid> <时间间隔，毫秒>`","source":"_posts/组件运维常用命令.md","raw":"---\ntitle: 组件运维常用命令\ndate: 2020-03-24 20:19:01\ntags:\n - Linux\n - 大数据组件\ncategories: 运维\n---\n\n\n\n组件日常运维命令，云备份。\n\n<!-- more -->\n\n# 服务常用命令【自用】\n\n## Zookeeper\n\n**zk snapshot 格式化**  \n`java -cp ~/software/zookeeper-3.4.6.5/zookeeper-3.4.6.5.jar:/home/zookeeper/software/zookeeper/lib/* org.apache.zookeeper.server.SnapshotFormatter <snapshot文件路径> > ./snapshot.test`\n格式化之后可以通过解析文本获取到znode的相关信息，减少对zk集群访问的压力。\n\n**ZK log日志格式化**\n可以查看服务器的事务操作\n`java -cp .:/home/zookeeper/software/zookeeper/zookeeper-3.4.6.5.jar:/home/zookeeper/software/zookeeper/lib/* org.apache.zookeeper.server.LogFormatter /home/zookeeper/logs/version-2/log.701f247da >> ./logtest`\n\n## Linux\n1. 查看服务端口是否正常 \n   `nc -z -w 1 127.0.0.1 8090 `\n\n2. 查看进程端口\n\n   `netstat -anp |grep <port>`\n\n3. 查看机器CPU和内存资源占用情况\n\n   `top`\n\n4. 查看单个进程的线程占用资源情况\n\n   `top -Hp <pid>`\n\n5. 十进制转十六机制，用来转换线程id，好在stack中搜索\n\n   `printf %x <十进制数>`\n\n\n\n## JVM分析\n**内存分析**\n\n1. 查看内存中对象及其占用的空间\n\n   `jmap -histo pid`\n\n2. 查看进程的堆栈信息，可以通过搜索线程ID查看当前阻塞线程\n\n   `jstack <pid> | vim -`\n\n3. 查看GC情况\n\n   `jstat -gcutil <pid> <时间间隔，毫秒>`","slug":"组件运维常用命令","published":1,"updated":"2020-03-24T12:32:49.048Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8tjbxu000096gon2wxt5wen","content":"<p>组件日常运维命令，云备份。</p>\n<a id=\"more\"></a>\n<h1 id=\"服务常用命令【自用】\"><a href=\"#服务常用命令【自用】\" class=\"headerlink\" title=\"服务常用命令【自用】\"></a>服务常用命令【自用】</h1><h2 id=\"Zookeeper\"><a href=\"#Zookeeper\" class=\"headerlink\" title=\"Zookeeper\"></a>Zookeeper</h2><p><strong>zk snapshot 格式化</strong><br><code>java -cp ~/software/zookeeper-3.4.6.5/zookeeper-3.4.6.5.jar:/home/zookeeper/software/zookeeper/lib/* org.apache.zookeeper.server.SnapshotFormatter &lt;snapshot文件路径&gt; &gt; ./snapshot.test</code><br>格式化之后可以通过解析文本获取到znode的相关信息，减少对zk集群访问的压力。</p>\n<p><strong>ZK log日志格式化</strong><br>可以查看服务器的事务操作<br><code>java -cp .:/home/zookeeper/software/zookeeper/zookeeper-3.4.6.5.jar:/home/zookeeper/software/zookeeper/lib/* org.apache.zookeeper.server.LogFormatter /home/zookeeper/logs/version-2/log.701f247da &gt;&gt; ./logtest</code></p>\n<h2 id=\"Linux\"><a href=\"#Linux\" class=\"headerlink\" title=\"Linux\"></a>Linux</h2><ol>\n<li><p>查看服务端口是否正常<br><code>nc -z -w 1 127.0.0.1 8090</code></p>\n</li>\n<li><p>查看进程端口</p>\n<p><code>netstat -anp |grep &lt;port&gt;</code></p>\n</li>\n<li><p>查看机器CPU和内存资源占用情况</p>\n<p><code>top</code></p>\n</li>\n<li><p>查看单个进程的线程占用资源情况</p>\n<p><code>top -Hp &lt;pid&gt;</code></p>\n</li>\n<li><p>十进制转十六机制，用来转换线程id，好在stack中搜索</p>\n<p><code>printf %x &lt;十进制数&gt;</code></p>\n</li>\n</ol>\n<h2 id=\"JVM分析\"><a href=\"#JVM分析\" class=\"headerlink\" title=\"JVM分析\"></a>JVM分析</h2><p><strong>内存分析</strong></p>\n<ol>\n<li><p>查看内存中对象及其占用的空间</p>\n<p><code>jmap -histo pid</code></p>\n</li>\n<li><p>查看进程的堆栈信息，可以通过搜索线程ID查看当前阻塞线程</p>\n<p><code>jstack &lt;pid&gt; | vim -</code></p>\n</li>\n<li><p>查看GC情况</p>\n<p><code>jstat -gcutil &lt;pid&gt; &lt;时间间隔，毫秒&gt;</code></p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>组件日常运维命令，云备份。</p>","more":"<h1 id=\"服务常用命令【自用】\"><a href=\"#服务常用命令【自用】\" class=\"headerlink\" title=\"服务常用命令【自用】\"></a>服务常用命令【自用】</h1><h2 id=\"Zookeeper\"><a href=\"#Zookeeper\" class=\"headerlink\" title=\"Zookeeper\"></a>Zookeeper</h2><p><strong>zk snapshot 格式化</strong><br><code>java -cp ~/software/zookeeper-3.4.6.5/zookeeper-3.4.6.5.jar:/home/zookeeper/software/zookeeper/lib/* org.apache.zookeeper.server.SnapshotFormatter &lt;snapshot文件路径&gt; &gt; ./snapshot.test</code><br>格式化之后可以通过解析文本获取到znode的相关信息，减少对zk集群访问的压力。</p>\n<p><strong>ZK log日志格式化</strong><br>可以查看服务器的事务操作<br><code>java -cp .:/home/zookeeper/software/zookeeper/zookeeper-3.4.6.5.jar:/home/zookeeper/software/zookeeper/lib/* org.apache.zookeeper.server.LogFormatter /home/zookeeper/logs/version-2/log.701f247da &gt;&gt; ./logtest</code></p>\n<h2 id=\"Linux\"><a href=\"#Linux\" class=\"headerlink\" title=\"Linux\"></a>Linux</h2><ol>\n<li><p>查看服务端口是否正常<br><code>nc -z -w 1 127.0.0.1 8090</code></p>\n</li>\n<li><p>查看进程端口</p>\n<p><code>netstat -anp |grep &lt;port&gt;</code></p>\n</li>\n<li><p>查看机器CPU和内存资源占用情况</p>\n<p><code>top</code></p>\n</li>\n<li><p>查看单个进程的线程占用资源情况</p>\n<p><code>top -Hp &lt;pid&gt;</code></p>\n</li>\n<li><p>十进制转十六机制，用来转换线程id，好在stack中搜索</p>\n<p><code>printf %x &lt;十进制数&gt;</code></p>\n</li>\n</ol>\n<h2 id=\"JVM分析\"><a href=\"#JVM分析\" class=\"headerlink\" title=\"JVM分析\"></a>JVM分析</h2><p><strong>内存分析</strong></p>\n<ol>\n<li><p>查看内存中对象及其占用的空间</p>\n<p><code>jmap -histo pid</code></p>\n</li>\n<li><p>查看进程的堆栈信息，可以通过搜索线程ID查看当前阻塞线程</p>\n<p><code>jstack &lt;pid&gt; | vim -</code></p>\n</li>\n<li><p>查看GC情况</p>\n<p><code>jstat -gcutil &lt;pid&gt; &lt;时间间隔，毫秒&gt;</code></p>\n</li>\n</ol>"},{"title":"火焰图实践","date":"2020-03-22T08:03:15.000Z","_content":"\n因为生产环境组件服务进程执行缓慢导致部分资源无法释放，进而引起了各种任务超时。研究源码发现，部分执行过长的是操作都是在单线程中串行 。这就意味着，单个过程的执行效率会影响到整个流程的调度周期。为此，我们需要对部分组件源码进行改造，串行改并行。  \n串行改并行，我们要小心流程执行顺序之间的依赖关系和各个线程对共享变量的读写。这里的前提是我们得知道改哪里。其实我们的需求很明确，执行过程耗时长的我们优先改造,也就是我们需要找到组件的性能瓶颈。但是如何确认呢?最终，我是通过火焰图观察，找出了耗时比较长的过程。下面记录一下这个过程，以便日后需要的时候可以有所帮助。  \n\n![](01.png)\n\n<!-- more -->\n\n## 2. 火焰图  \n\n> 火焰图是通过可交互的图片反映出程序执行过程中的调用栈和大致的CPU占用百分比。在火焰图中，顺着Y轴从下往上看表示的是调用顺序，高度表示的就是调用栈的深度。顺着X轴看，一个方法的长度表示的就是这个方法的被抽到的样本数，被抽到的次数越多，占用的CPU时间就越长。当把鼠标放在一个方法上时，会显示一段说明，例如`(5222 samples, 7.6%)`,这个表示的就是，这个方法在采样期间被采样了5222次，占用总样本的7.6%。注意X轴不表示时间，不是说左边的方法一定在右边之前执行。火焰图应该是高低起伏的，如果都是很宽的平顶，那程序性能就需要重新评测了。另外，火焰图的颜色没有任何含义。\n\n火焰图是可交互的，在浏览器中我们打开火焰图之后可以直接`CTRL+F`进行搜索。输入完整的方法名或者正则表达式之后，所有匹配到的方法都是高亮显示出来。    \n\n![Search.png](02.png)  \n单击这些高亮部分就会放大这一部分，显示选中方法的子方法(被调用的方法)。这样就可以在这张图中搜索自己想要确认的模块，然后找到比较宽的部分，定位到代码，确定是否可以修改。  \n\n## 3. 生成火焰图  \n\n### 3.1 工具  \n\n火焰图生成工具：[javaPfro.zip](https://pan.baidu.com/s/1EuIauy4rFNxaIwXhMAXW5Q) \n提取码：`76o9`  \n这个工具包解压之后会用两个文件夹：  \n`async-profiler-master`\n`FlameGraph-master`  \n文件夹下部分可执行文件，可能需要755权限。这里不做一一声明，直接更改文件夹下所有文件的权限。  \n`chmod -R 755 async-profiler-master/*`  \n`chmod -R 755 FlameGraph-master/*`\n\n### 3.2 操作步骤  \n\n> 火焰图只是以图片形式展示出了CPU中的调用栈，实际的数据还是需要从CPU中采集。所以生成火焰图共分为两步：采样和生成svg图。\n> ####3.2.1 采样  \n> 采样使用`async-profiler-master`工具，具体命令如下：  \n> `./async-profiler-master/profiler.sh -d 10 -o collapsed -f /tmp/collapsed.txt 1234`  \n> 以上命令表示的意思是，采样时间为10秒，采样得到的数据重定向到`/tmp/collapsed.txt `，被采样进程id为1234。  \n\n#### 3.2.2 生成svg图  \n\n根据采样数据生成svg图，使用的是` FlameGraph-master`,具体命令如下:  \n`./FlameGraph-master/flamegraph.pl --colors=java /tmp/collapsed.txt > flamegraph.svg`  \n命令表示的意思是把`/tmp/collapsed.txt`这个文件转换svg火焰图，文件名为`flamegraph.svg`。  \n然后,把这个文件拉到window环境下，用浏览器就可以打开了。这里我用的是chrome浏览器。    \n\n## 4. 分析火焰图  \n\n分析火焰图一般需要先确定需要分析的类或方法名，或者代码入口方法，或者入口类。这样我们可以先定位到一个方法调用，再分析其调用栈。  \n![](03.png)\n例如，在这张图片中，我确定的方法是定义在`CoordinatorRunnable`类中的，就可以直接搜索这个类。定位到这个类我们可以明显地看到有三个方法占用了大部分的时间。再继续追踪调用栈。  \n![](04.png)\n可以看出，耗时大部分都花费在集合元素的比较上。这里我们如果需要优化的话，可以考虑一下比较器的逻辑或者可以根据场景判断一下是否可以选择其他的集合等等。\n\n","source":"_posts/火焰图实践.md","raw":"---\ntitle: 火焰图实践\ndate: 2020-03-22 16:03:15\ntags:\n - Java\n - Problem Shoting\n - 性能分析\n - 火焰图\ncategories: 代码分析\n---\n\n因为生产环境组件服务进程执行缓慢导致部分资源无法释放，进而引起了各种任务超时。研究源码发现，部分执行过长的是操作都是在单线程中串行 。这就意味着，单个过程的执行效率会影响到整个流程的调度周期。为此，我们需要对部分组件源码进行改造，串行改并行。  \n串行改并行，我们要小心流程执行顺序之间的依赖关系和各个线程对共享变量的读写。这里的前提是我们得知道改哪里。其实我们的需求很明确，执行过程耗时长的我们优先改造,也就是我们需要找到组件的性能瓶颈。但是如何确认呢?最终，我是通过火焰图观察，找出了耗时比较长的过程。下面记录一下这个过程，以便日后需要的时候可以有所帮助。  \n\n![](01.png)\n\n<!-- more -->\n\n## 2. 火焰图  \n\n> 火焰图是通过可交互的图片反映出程序执行过程中的调用栈和大致的CPU占用百分比。在火焰图中，顺着Y轴从下往上看表示的是调用顺序，高度表示的就是调用栈的深度。顺着X轴看，一个方法的长度表示的就是这个方法的被抽到的样本数，被抽到的次数越多，占用的CPU时间就越长。当把鼠标放在一个方法上时，会显示一段说明，例如`(5222 samples, 7.6%)`,这个表示的就是，这个方法在采样期间被采样了5222次，占用总样本的7.6%。注意X轴不表示时间，不是说左边的方法一定在右边之前执行。火焰图应该是高低起伏的，如果都是很宽的平顶，那程序性能就需要重新评测了。另外，火焰图的颜色没有任何含义。\n\n火焰图是可交互的，在浏览器中我们打开火焰图之后可以直接`CTRL+F`进行搜索。输入完整的方法名或者正则表达式之后，所有匹配到的方法都是高亮显示出来。    \n\n![Search.png](02.png)  \n单击这些高亮部分就会放大这一部分，显示选中方法的子方法(被调用的方法)。这样就可以在这张图中搜索自己想要确认的模块，然后找到比较宽的部分，定位到代码，确定是否可以修改。  \n\n## 3. 生成火焰图  \n\n### 3.1 工具  \n\n火焰图生成工具：[javaPfro.zip](https://pan.baidu.com/s/1EuIauy4rFNxaIwXhMAXW5Q) \n提取码：`76o9`  \n这个工具包解压之后会用两个文件夹：  \n`async-profiler-master`\n`FlameGraph-master`  \n文件夹下部分可执行文件，可能需要755权限。这里不做一一声明，直接更改文件夹下所有文件的权限。  \n`chmod -R 755 async-profiler-master/*`  \n`chmod -R 755 FlameGraph-master/*`\n\n### 3.2 操作步骤  \n\n> 火焰图只是以图片形式展示出了CPU中的调用栈，实际的数据还是需要从CPU中采集。所以生成火焰图共分为两步：采样和生成svg图。\n> ####3.2.1 采样  \n> 采样使用`async-profiler-master`工具，具体命令如下：  \n> `./async-profiler-master/profiler.sh -d 10 -o collapsed -f /tmp/collapsed.txt 1234`  \n> 以上命令表示的意思是，采样时间为10秒，采样得到的数据重定向到`/tmp/collapsed.txt `，被采样进程id为1234。  \n\n#### 3.2.2 生成svg图  \n\n根据采样数据生成svg图，使用的是` FlameGraph-master`,具体命令如下:  \n`./FlameGraph-master/flamegraph.pl --colors=java /tmp/collapsed.txt > flamegraph.svg`  \n命令表示的意思是把`/tmp/collapsed.txt`这个文件转换svg火焰图，文件名为`flamegraph.svg`。  \n然后,把这个文件拉到window环境下，用浏览器就可以打开了。这里我用的是chrome浏览器。    \n\n## 4. 分析火焰图  \n\n分析火焰图一般需要先确定需要分析的类或方法名，或者代码入口方法，或者入口类。这样我们可以先定位到一个方法调用，再分析其调用栈。  \n![](03.png)\n例如，在这张图片中，我确定的方法是定义在`CoordinatorRunnable`类中的，就可以直接搜索这个类。定位到这个类我们可以明显地看到有三个方法占用了大部分的时间。再继续追踪调用栈。  \n![](04.png)\n可以看出，耗时大部分都花费在集合元素的比较上。这里我们如果需要优化的话，可以考虑一下比较器的逻辑或者可以根据场景判断一下是否可以选择其他的集合等等。\n\n","slug":"火焰图实践","published":1,"updated":"2020-03-22T08:25:17.887Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8tjbxu1000a6gon3f1sy9tx","content":"<p>因为生产环境组件服务进程执行缓慢导致部分资源无法释放，进而引起了各种任务超时。研究源码发现，部分执行过长的是操作都是在单线程中串行 。这就意味着，单个过程的执行效率会影响到整个流程的调度周期。为此，我们需要对部分组件源码进行改造，串行改并行。<br>串行改并行，我们要小心流程执行顺序之间的依赖关系和各个线程对共享变量的读写。这里的前提是我们得知道改哪里。其实我们的需求很明确，执行过程耗时长的我们优先改造,也就是我们需要找到组件的性能瓶颈。但是如何确认呢?最终，我是通过火焰图观察，找出了耗时比较长的过程。下面记录一下这个过程，以便日后需要的时候可以有所帮助。  </p>\n<p><img src=\"01.png\" alt></p>\n<a id=\"more\"></a>\n<h2 id=\"2-火焰图\"><a href=\"#2-火焰图\" class=\"headerlink\" title=\"2. 火焰图\"></a>2. 火焰图</h2><blockquote>\n<p>火焰图是通过可交互的图片反映出程序执行过程中的调用栈和大致的CPU占用百分比。在火焰图中，顺着Y轴从下往上看表示的是调用顺序，高度表示的就是调用栈的深度。顺着X轴看，一个方法的长度表示的就是这个方法的被抽到的样本数，被抽到的次数越多，占用的CPU时间就越长。当把鼠标放在一个方法上时，会显示一段说明，例如<code>(5222 samples, 7.6%)</code>,这个表示的就是，这个方法在采样期间被采样了5222次，占用总样本的7.6%。注意X轴不表示时间，不是说左边的方法一定在右边之前执行。火焰图应该是高低起伏的，如果都是很宽的平顶，那程序性能就需要重新评测了。另外，火焰图的颜色没有任何含义。</p>\n</blockquote>\n<p>火焰图是可交互的，在浏览器中我们打开火焰图之后可以直接<code>CTRL+F</code>进行搜索。输入完整的方法名或者正则表达式之后，所有匹配到的方法都是高亮显示出来。    </p>\n<p><img src=\"02.png\" alt=\"Search.png\"><br>单击这些高亮部分就会放大这一部分，显示选中方法的子方法(被调用的方法)。这样就可以在这张图中搜索自己想要确认的模块，然后找到比较宽的部分，定位到代码，确定是否可以修改。  </p>\n<h2 id=\"3-生成火焰图\"><a href=\"#3-生成火焰图\" class=\"headerlink\" title=\"3. 生成火焰图\"></a>3. 生成火焰图</h2><h3 id=\"3-1-工具\"><a href=\"#3-1-工具\" class=\"headerlink\" title=\"3.1 工具\"></a>3.1 工具</h3><p>火焰图生成工具：<a href=\"https://pan.baidu.com/s/1EuIauy4rFNxaIwXhMAXW5Q\" target=\"_blank\" rel=\"noopener\">javaPfro.zip</a><br>提取码：<code>76o9</code><br>这个工具包解压之后会用两个文件夹：<br><code>async-profiler-master</code><br><code>FlameGraph-master</code><br>文件夹下部分可执行文件，可能需要755权限。这里不做一一声明，直接更改文件夹下所有文件的权限。<br><code>chmod -R 755 async-profiler-master/*</code><br><code>chmod -R 755 FlameGraph-master/*</code></p>\n<h3 id=\"3-2-操作步骤\"><a href=\"#3-2-操作步骤\" class=\"headerlink\" title=\"3.2 操作步骤\"></a>3.2 操作步骤</h3><blockquote>\n<p>火焰图只是以图片形式展示出了CPU中的调用栈，实际的数据还是需要从CPU中采集。所以生成火焰图共分为两步：采样和生成svg图。</p>\n<p>####3.2.1 采样<br>采样使用<code>async-profiler-master</code>工具，具体命令如下：<br><code>./async-profiler-master/profiler.sh -d 10 -o collapsed -f /tmp/collapsed.txt 1234</code><br>以上命令表示的意思是，采样时间为10秒，采样得到的数据重定向到<code>/tmp/collapsed.txt</code>，被采样进程id为1234。  </p>\n</blockquote>\n<h4 id=\"3-2-2-生成svg图\"><a href=\"#3-2-2-生成svg图\" class=\"headerlink\" title=\"3.2.2 生成svg图\"></a>3.2.2 生成svg图</h4><p>根据采样数据生成svg图，使用的是<code>FlameGraph-master</code>,具体命令如下:<br><code>./FlameGraph-master/flamegraph.pl --colors=java /tmp/collapsed.txt &gt; flamegraph.svg</code><br>命令表示的意思是把<code>/tmp/collapsed.txt</code>这个文件转换svg火焰图，文件名为<code>flamegraph.svg</code>。<br>然后,把这个文件拉到window环境下，用浏览器就可以打开了。这里我用的是chrome浏览器。    </p>\n<h2 id=\"4-分析火焰图\"><a href=\"#4-分析火焰图\" class=\"headerlink\" title=\"4. 分析火焰图\"></a>4. 分析火焰图</h2><p>分析火焰图一般需要先确定需要分析的类或方法名，或者代码入口方法，或者入口类。这样我们可以先定位到一个方法调用，再分析其调用栈。<br><img src=\"03.png\" alt><br>例如，在这张图片中，我确定的方法是定义在<code>CoordinatorRunnable</code>类中的，就可以直接搜索这个类。定位到这个类我们可以明显地看到有三个方法占用了大部分的时间。再继续追踪调用栈。<br><img src=\"04.png\" alt><br>可以看出，耗时大部分都花费在集合元素的比较上。这里我们如果需要优化的话，可以考虑一下比较器的逻辑或者可以根据场景判断一下是否可以选择其他的集合等等。</p>\n","site":{"data":{}},"excerpt":"<p>因为生产环境组件服务进程执行缓慢导致部分资源无法释放，进而引起了各种任务超时。研究源码发现，部分执行过长的是操作都是在单线程中串行 。这就意味着，单个过程的执行效率会影响到整个流程的调度周期。为此，我们需要对部分组件源码进行改造，串行改并行。<br>串行改并行，我们要小心流程执行顺序之间的依赖关系和各个线程对共享变量的读写。这里的前提是我们得知道改哪里。其实我们的需求很明确，执行过程耗时长的我们优先改造,也就是我们需要找到组件的性能瓶颈。但是如何确认呢?最终，我是通过火焰图观察，找出了耗时比较长的过程。下面记录一下这个过程，以便日后需要的时候可以有所帮助。  </p>\n<p><img src=\"01.png\" alt></p>","more":"<h2 id=\"2-火焰图\"><a href=\"#2-火焰图\" class=\"headerlink\" title=\"2. 火焰图\"></a>2. 火焰图</h2><blockquote>\n<p>火焰图是通过可交互的图片反映出程序执行过程中的调用栈和大致的CPU占用百分比。在火焰图中，顺着Y轴从下往上看表示的是调用顺序，高度表示的就是调用栈的深度。顺着X轴看，一个方法的长度表示的就是这个方法的被抽到的样本数，被抽到的次数越多，占用的CPU时间就越长。当把鼠标放在一个方法上时，会显示一段说明，例如<code>(5222 samples, 7.6%)</code>,这个表示的就是，这个方法在采样期间被采样了5222次，占用总样本的7.6%。注意X轴不表示时间，不是说左边的方法一定在右边之前执行。火焰图应该是高低起伏的，如果都是很宽的平顶，那程序性能就需要重新评测了。另外，火焰图的颜色没有任何含义。</p>\n</blockquote>\n<p>火焰图是可交互的，在浏览器中我们打开火焰图之后可以直接<code>CTRL+F</code>进行搜索。输入完整的方法名或者正则表达式之后，所有匹配到的方法都是高亮显示出来。    </p>\n<p><img src=\"02.png\" alt=\"Search.png\"><br>单击这些高亮部分就会放大这一部分，显示选中方法的子方法(被调用的方法)。这样就可以在这张图中搜索自己想要确认的模块，然后找到比较宽的部分，定位到代码，确定是否可以修改。  </p>\n<h2 id=\"3-生成火焰图\"><a href=\"#3-生成火焰图\" class=\"headerlink\" title=\"3. 生成火焰图\"></a>3. 生成火焰图</h2><h3 id=\"3-1-工具\"><a href=\"#3-1-工具\" class=\"headerlink\" title=\"3.1 工具\"></a>3.1 工具</h3><p>火焰图生成工具：<a href=\"https://pan.baidu.com/s/1EuIauy4rFNxaIwXhMAXW5Q\" target=\"_blank\" rel=\"noopener\">javaPfro.zip</a><br>提取码：<code>76o9</code><br>这个工具包解压之后会用两个文件夹：<br><code>async-profiler-master</code><br><code>FlameGraph-master</code><br>文件夹下部分可执行文件，可能需要755权限。这里不做一一声明，直接更改文件夹下所有文件的权限。<br><code>chmod -R 755 async-profiler-master/*</code><br><code>chmod -R 755 FlameGraph-master/*</code></p>\n<h3 id=\"3-2-操作步骤\"><a href=\"#3-2-操作步骤\" class=\"headerlink\" title=\"3.2 操作步骤\"></a>3.2 操作步骤</h3><blockquote>\n<p>火焰图只是以图片形式展示出了CPU中的调用栈，实际的数据还是需要从CPU中采集。所以生成火焰图共分为两步：采样和生成svg图。</p>\n<p>####3.2.1 采样<br>采样使用<code>async-profiler-master</code>工具，具体命令如下：<br><code>./async-profiler-master/profiler.sh -d 10 -o collapsed -f /tmp/collapsed.txt 1234</code><br>以上命令表示的意思是，采样时间为10秒，采样得到的数据重定向到<code>/tmp/collapsed.txt</code>，被采样进程id为1234。  </p>\n</blockquote>\n<h4 id=\"3-2-2-生成svg图\"><a href=\"#3-2-2-生成svg图\" class=\"headerlink\" title=\"3.2.2 生成svg图\"></a>3.2.2 生成svg图</h4><p>根据采样数据生成svg图，使用的是<code>FlameGraph-master</code>,具体命令如下:<br><code>./FlameGraph-master/flamegraph.pl --colors=java /tmp/collapsed.txt &gt; flamegraph.svg</code><br>命令表示的意思是把<code>/tmp/collapsed.txt</code>这个文件转换svg火焰图，文件名为<code>flamegraph.svg</code>。<br>然后,把这个文件拉到window环境下，用浏览器就可以打开了。这里我用的是chrome浏览器。    </p>\n<h2 id=\"4-分析火焰图\"><a href=\"#4-分析火焰图\" class=\"headerlink\" title=\"4. 分析火焰图\"></a>4. 分析火焰图</h2><p>分析火焰图一般需要先确定需要分析的类或方法名，或者代码入口方法，或者入口类。这样我们可以先定位到一个方法调用，再分析其调用栈。<br><img src=\"03.png\" alt><br>例如，在这张图片中，我确定的方法是定义在<code>CoordinatorRunnable</code>类中的，就可以直接搜索这个类。定位到这个类我们可以明显地看到有三个方法占用了大部分的时间。再继续追踪调用栈。<br><img src=\"04.png\" alt><br>可以看出，耗时大部分都花费在集合元素的比较上。这里我们如果需要优化的话，可以考虑一下比较器的逻辑或者可以根据场景判断一下是否可以选择其他的集合等等。</p>"}],"PostAsset":[{"_id":"source/_posts/火焰图实践/01.png","slug":"01.png","post":"ck8tjbxu1000a6gon3f1sy9tx","modified":1,"renderable":0},{"_id":"source/_posts/Coordinator源码分析/DruidCoordinator源码分析01.png","post":"ck8tjbxtv00046gonmrhn7ds2","slug":"DruidCoordinator源码分析01.png","modified":1,"renderable":1},{"_id":"source/_posts/Coordinator源码分析/DruidCoordinator源码分析02.png","post":"ck8tjbxtv00046gonmrhn7ds2","slug":"DruidCoordinator源码分析02.png","modified":1,"renderable":1},{"_id":"source/_posts/Coordinator源码分析/DruidCoordinator源码分析03.png","post":"ck8tjbxtv00046gonmrhn7ds2","slug":"DruidCoordinator源码分析03.png","modified":1,"renderable":1},{"_id":"source/_posts/【翻译】Zookeeper01-Zookeeper简介/zkcomponents.jpg","post":"ck8tjbxty00066gonx5jmues6","slug":"zkcomponents.jpg","modified":1,"renderable":1},{"_id":"source/_posts/【翻译】Zookeeper01-Zookeeper简介/zknamespace.jpg","post":"ck8tjbxty00066gonx5jmues6","slug":"zknamespace.jpg","modified":1,"renderable":1},{"_id":"source/_posts/【翻译】Zookeeper01-Zookeeper简介/zkservice.jpg","post":"ck8tjbxty00066gonx5jmues6","slug":"zkservice.jpg","modified":1,"renderable":1},{"_id":"source/_posts/火焰图实践/02.png","post":"ck8tjbxu1000a6gon3f1sy9tx","slug":"02.png","modified":1,"renderable":1},{"_id":"source/_posts/火焰图实践/03.png","post":"ck8tjbxu1000a6gon3f1sy9tx","slug":"03.png","modified":1,"renderable":1},{"_id":"source/_posts/火焰图实践/04.png","post":"ck8tjbxu1000a6gon3f1sy9tx","slug":"04.png","modified":1,"renderable":1},{"_id":"source/_posts/Java线程池原理/01.png","post":"ck8tjbxtw00056gonyxmqziat","slug":"01.png","modified":1,"renderable":1},{"_id":"source/_posts/Java线程池原理/02.png","post":"ck8tjbxtw00056gonyxmqziat","slug":"02.png","modified":1,"renderable":1},{"_id":"source/_posts/Java线程池原理/03.png","post":"ck8tjbxtw00056gonyxmqziat","slug":"03.png","modified":1,"renderable":1},{"_id":"source/_posts/Java线程池原理/04.png","post":"ck8tjbxtw00056gonyxmqziat","slug":"04.png","modified":1,"renderable":1},{"_id":"source/_posts/Java线程池原理/05.png","post":"ck8tjbxtw00056gonyxmqziat","slug":"05.png","modified":1,"renderable":1},{"_id":"source/_posts/Java线程池原理/06.png","post":"ck8tjbxtw00056gonyxmqziat","slug":"06.png","modified":1,"renderable":1}],"PostCategory":[{"post_id":"ck8tjbxtw00056gonyxmqziat","category_id":"ck8tjbxtt00026gon63b3uml1","_id":"ck8tjbxu2000b6gonlg19b5zq"},{"post_id":"ck8tjbxtm00006gon0701585i","category_id":"ck8tjbxtt00026gon63b3uml1","_id":"ck8tjbxu3000e6gonbk1qj1po"},{"post_id":"ck8tjbxtv00046gonmrhn7ds2","category_id":"ck8tjbxtz00076gondfignklh","_id":"ck8tjbxu4000f6gonhef0e89h"},{"post_id":"ck8tjbxu000096gon2wxt5wen","category_id":"ck8tjbxu4000g6goncx7c6mle","_id":"ck8tjbxu6000m6gon8qjbzge3"},{"post_id":"ck8tjbxu1000a6gon3f1sy9tx","category_id":"ck8tjbxu5000i6gonvnatfpfv","_id":"ck8tjbxu7000r6gon3no2h0f9"},{"post_id":"ck8tjbxty00066gonx5jmues6","category_id":"ck8tjbxu2000c6gont5l63suz","_id":"ck8tjbxu8000t6gon1q1dshyy"},{"post_id":"ck8tjbxty00066gonx5jmues6","category_id":"ck8tjbxu6000n6gonbatfp7wt","_id":"ck8tjbxu8000v6gonxxs3wzn4"}],"PostTag":[{"post_id":"ck8tjbxtm00006gon0701585i","tag_id":"ck8tjbxtv00036gone919frsd","_id":"ck8tjbxu6000k6gonoih89c3k"},{"post_id":"ck8tjbxtm00006gon0701585i","tag_id":"ck8tjbxtz00086gonnlxdqamt","_id":"ck8tjbxu6000l6gon9ffpzu34"},{"post_id":"ck8tjbxtm00006gon0701585i","tag_id":"ck8tjbxu3000d6gon88gm9wru","_id":"ck8tjbxu7000p6gons4rfolb7"},{"post_id":"ck8tjbxtm00006gon0701585i","tag_id":"ck8tjbxu5000h6gonp2hn82hd","_id":"ck8tjbxu7000q6gone2bvkeak"},{"post_id":"ck8tjbxtv00046gonmrhn7ds2","tag_id":"ck8tjbxu5000j6gonbau1e1ok","_id":"ck8tjbxu9000w6gon0xhlu58u"},{"post_id":"ck8tjbxtv00046gonmrhn7ds2","tag_id":"ck8tjbxu7000o6gon4ex5o6tq","_id":"ck8tjbxu9000x6gonl7pom7ts"},{"post_id":"ck8tjbxtv00046gonmrhn7ds2","tag_id":"ck8tjbxu8000s6gonmlb7fue0","_id":"ck8tjbxua000z6gon5zld9qxg"},{"post_id":"ck8tjbxtw00056gonyxmqziat","tag_id":"ck8tjbxu8000u6gons8mrli17","_id":"ck8tjbxub00126gonfwukqcm3"},{"post_id":"ck8tjbxtw00056gonyxmqziat","tag_id":"ck8tjbxtz00086gonnlxdqamt","_id":"ck8tjbxub00136goncpn2w7td"},{"post_id":"ck8tjbxtw00056gonyxmqziat","tag_id":"ck8tjbxua00106gongm6xay82","_id":"ck8tjbxuc00156gonmc540yo8"},{"post_id":"ck8tjbxty00066gonx5jmues6","tag_id":"ck8tjbxub00116gont3r6dnxs","_id":"ck8tjbxuc00176gonmzm7ce7p"},{"post_id":"ck8tjbxty00066gonx5jmues6","tag_id":"ck8tjbxub00146gonq01o106a","_id":"ck8tjbxuc00186goniabwmr09"},{"post_id":"ck8tjbxu000096gon2wxt5wen","tag_id":"ck8tjbxuc00166gonr6fzofje","_id":"ck8tjbxud001b6gono2ivge22"},{"post_id":"ck8tjbxu000096gon2wxt5wen","tag_id":"ck8tjbxuc00196goncpbhsk17","_id":"ck8tjbxud001c6gonhqd12aee"},{"post_id":"ck8tjbxu1000a6gon3f1sy9tx","tag_id":"ck8tjbxu8000u6gons8mrli17","_id":"ck8tjbxue001g6gonmp3nxgia"},{"post_id":"ck8tjbxu1000a6gon3f1sy9tx","tag_id":"ck8tjbxue001d6gonznm6thoa","_id":"ck8tjbxuf001h6gon0gfbi5l3"},{"post_id":"ck8tjbxu1000a6gon3f1sy9tx","tag_id":"ck8tjbxue001e6gon6k3xqvdj","_id":"ck8tjbxuf001i6gonw0ogopmx"},{"post_id":"ck8tjbxu1000a6gon3f1sy9tx","tag_id":"ck8tjbxue001f6gon11v2id3c","_id":"ck8tjbxuf001j6gont0j7fd2v"}],"Tag":[{"name":"java","_id":"ck8tjbxtv00036gone919frsd"},{"name":"多线程","_id":"ck8tjbxtz00086gonnlxdqamt"},{"name":"asyn/syn","_id":"ck8tjbxu3000d6gon88gm9wru"},{"name":"JUC","_id":"ck8tjbxu5000h6gonp2hn82hd"},{"name":"Apache Druid","_id":"ck8tjbxu5000j6gonbau1e1ok"},{"name":"Bigdata","_id":"ck8tjbxu7000o6gon4ex5o6tq"},{"name":"OLAP","_id":"ck8tjbxu8000s6gonmlb7fue0"},{"name":"Java","_id":"ck8tjbxu8000u6gons8mrli17"},{"name":"线程池","_id":"ck8tjbxua00106gongm6xay82"},{"name":"zookeeper","_id":"ck8tjbxub00116gont3r6dnxs"},{"name":"大数据","_id":"ck8tjbxub00146gonq01o106a"},{"name":"Linux","_id":"ck8tjbxuc00166gonr6fzofje"},{"name":"大数据组件","_id":"ck8tjbxuc00196goncpbhsk17"},{"name":"Problem Shoting","_id":"ck8tjbxue001d6gonznm6thoa"},{"name":"性能分析","_id":"ck8tjbxue001e6gon6k3xqvdj"},{"name":"火焰图","_id":"ck8tjbxue001f6gon11v2id3c"}]}}